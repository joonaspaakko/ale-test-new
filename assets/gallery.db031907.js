import { m as makeCoverUrl } from "./gallery-makeCoverUrl.8378190f.js";
import { o as openBlock, c as createElementBlock, a as createBaseVNode, _ as _export_sfc, r as resolveComponent, b as resolveDirective, w as withDirectives, v as vShow, n as normalizeStyle, d as createVNode, t as toDisplayString, e as createCommentVNode, p as pushScopeId, f as popScopeId, g as normalizeClass, h as withModifiers, i as createBlock, F as Fragment, j as renderList, k as withCtx, l as normalizeProps, m as resolveDynamicComponent, q as renderSlot, s as createStaticVNode, u as vModelCheckbox, x as createTextVNode, y as vModelRadio, z as _$1, A as shallowRef, B as unref, C as computed, D as reactive, E as nextTick, G as defineComponent, H as inject, I as h, J as provide, K as ref, L as watch, M as createApp } from "./lodash.1321b47a.js";
import { c as commonjsGlobal, g as getDefaultExportFromCjs } from "./jquery.050764e9.js";
import { r as require$$0, s as shortkey } from "./index.ee874ed1.js";
import { U as Url, h as helpers } from "./content-script-helpers.e49fc91b.js";
import { h as howler } from "./howler.22814ddb.js";
import { c as createStore, m as mitt, V as VueTippy } from "./tippy.82bfa66a.js";
const _hoisted_1$B = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$y = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M18 13c0 3.31-2.69 6-6 6s-6-2.69-6-6s2.69-6 6-6v4l5-5l-5-5v4c-4.42 0-8 3.58-8 8s3.58 8 8 8s8-3.58 8-8h-2z"
}, null, -1);
const _hoisted_3$w = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M10.06 15.38c-.29 0-.62-.17-.62-.54h-.85c0 .97.9 1.23 1.45 1.23c.87 0 1.51-.46 1.51-1.25c0-.66-.45-.9-.71-1c.11-.05.65-.32.65-.92c0-.21-.05-1.22-1.44-1.22c-.62 0-1.4.35-1.4 1.16h.85c0-.34.31-.48.57-.48c.59 0 .58.5.58.54c0 .52-.41.59-.63.59h-.46v.66h.45c.65 0 .7.42.7.64c0 .32-.21.59-.65.59zm3.79-3.7c-.14 0-1.44-.08-1.44 1.82v.74c0 1.9 1.31 1.82 1.44 1.82c.14 0 1.44.09 1.44-1.82v-.74c.01-1.91-1.3-1.82-1.44-1.82zm.6 2.67c0 .77-.21 1.03-.59 1.03s-.6-.26-.6-1.03v-.97c0-.75.22-1.01.59-1.01c.38 0 .6.26.6 1.01v.97z"
}, null, -1);
const _hoisted_4$8 = [
  _hoisted_2$y,
  _hoisted_3$w
];
function render$o(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$B, _hoisted_4$8);
}
var __unplugin_components_4$4 = { name: "ic-baseline-forward30", render: render$o };
const _hoisted_1$A = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$x = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10s10-4.48 10-10S17.52 2 12 2zm-1 14H9V8h2v8zm4 0h-2V8h2v8z"
}, null, -1);
const _hoisted_3$v = [
  _hoisted_2$x
];
function render$n(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$A, _hoisted_3$v);
}
var __unplugin_components_2$3 = { name: "ic-sharp-pause-circle-filled", render: render$n };
const _hoisted_1$z = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$w = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10s10-4.48 10-10S17.52 2 12 2zm-2 14.5v-9l6 4.5l-6 4.5z"
}, null, -1);
const _hoisted_3$u = [
  _hoisted_2$w
];
function render$m(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$z, _hoisted_3$u);
}
var __unplugin_components_1$9 = { name: "ic-sharp-play-circle-filled", render: render$m };
const _hoisted_1$y = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$v = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6s-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8s-3.58-8-8-8z"
}, null, -1);
const _hoisted_3$t = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M9.56 13.49h.45c.21 0 .37-.05.48-.16s.16-.25.16-.43a.538.538 0 0 0-.15-.39c-.05-.05-.11-.09-.18-.11s-.16-.04-.25-.04c-.08 0-.15.01-.22.03s-.13.05-.18.1s-.09.09-.12.15s-.05.13-.05.2h-.85a1.06 1.06 0 0 1 .41-.85c.13-.1.27-.18.44-.23s.35-.08.54-.08c.21 0 .41.03.59.08s.33.13.46.23s.23.23.3.38s.11.33.11.53a.842.842 0 0 1-.17.52a1.1 1.1 0 0 1-.48.39c.24.09.42.21.54.39s.18.38.18.61c0 .2-.04.38-.12.53s-.18.29-.32.39s-.29.19-.48.24s-.38.08-.6.08c-.18 0-.36-.02-.53-.07s-.33-.12-.46-.23s-.25-.23-.33-.38s-.12-.34-.12-.55h.85c0 .08.02.15.05.22s.07.12.13.17s.12.09.2.11s.16.04.25.04c.1 0 .19-.01.27-.04s.15-.07.2-.12s.1-.11.13-.18s.04-.15.04-.24c0-.11-.02-.21-.05-.29s-.08-.15-.14-.2s-.13-.09-.22-.11s-.18-.04-.29-.04h-.47v-.65zm5.74.75c0 .32-.03.6-.1.82s-.17.42-.29.57s-.28.26-.45.33s-.37.1-.59.1s-.41-.03-.59-.1s-.33-.18-.46-.33s-.23-.34-.3-.57s-.11-.5-.11-.82v-.74c0-.32.03-.6.1-.82s.17-.42.29-.57s.28-.26.45-.33s.37-.1.59-.1s.41.03.59.1s.33.18.46.33s.23.34.3.57s.11.5.11.82v.74zm-.85-.86c0-.19-.01-.35-.04-.48s-.07-.23-.12-.31s-.11-.14-.19-.17s-.16-.05-.25-.05s-.18.02-.25.05s-.14.09-.19.17s-.09.18-.12.31s-.04.29-.04.48v.97c0 .19.01.35.04.48s.07.24.12.32s.11.14.19.17s.16.05.25.05s.18-.02.25-.05s.14-.09.19-.17s.09-.19.11-.32c.03-.13.04-.29.04-.48v-.97z"
}, null, -1);
const _hoisted_4$7 = [
  _hoisted_2$v,
  _hoisted_3$t
];
function render$l(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$y, _hoisted_4$7);
}
var __unplugin_components_3$4 = { name: "ic-baseline-replay30", render: render$l };
var antd = "";
var _default = "";
var vueSliderComponent_umd_min = { exports: {} };
(function(module, exports) {
  (function(t, e) {
    module.exports = e(require$$0);
  })("undefined" !== typeof self ? self : commonjsGlobal, function(t) {
    return function() {
      var e = { 679: function(t2, e2) {
        var r2, n2, i2;
        (function(o, a) {
          n2 = [], r2 = a, i2 = "function" === typeof r2 ? r2.apply(e2, n2) : r2, void 0 === i2 || (t2.exports = i2);
        })("undefined" !== typeof self && self, function() {
          function t3() {
            var e3 = Object.getOwnPropertyDescriptor(document, "currentScript");
            if (!e3 && "currentScript" in document && document.currentScript)
              return document.currentScript;
            if (e3 && e3.get !== t3 && document.currentScript)
              return document.currentScript;
            try {
              throw new Error();
            } catch (f) {
              var r3, n3, i3, o = /.*at [^(]*\((.*):(.+):(.+)\)$/gi, a = /@([^@]*):(\d+):(\d+)\s*$/gi, s = o.exec(f.stack) || a.exec(f.stack), l = s && s[1] || false, u = s && s[2] || false, c = document.location.href.replace(document.location.hash, ""), d = document.getElementsByTagName("script");
              l === c && (r3 = document.documentElement.outerHTML, n3 = new RegExp("(?:[^\\n]+?\\n){0," + (u - 2) + "}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*", "i"), i3 = r3.replace(n3, "$1").trim());
              for (var h2 = 0; h2 < d.length; h2++) {
                if ("interactive" === d[h2].readyState)
                  return d[h2];
                if (d[h2].src === l)
                  return d[h2];
                if (l === c && d[h2].innerHTML && d[h2].innerHTML.trim() === i3)
                  return d[h2];
              }
              return null;
            }
          }
          return t3;
        });
      }, 724: function(t2, e2, r2) {
        r2.r(e2);
        var n2 = r2(81), i2 = r2.n(n2), o = r2(645), a = r2.n(o), s = a()(i2());
        s.push([t2.id, ".vue-slider-dot{position:absolute;-webkit-transition:all 0s;transition:all 0s;z-index:5}.vue-slider-dot:focus{outline:none}.vue-slider-dot-tooltip{position:absolute;visibility:hidden}.vue-slider-dot-hover:hover .vue-slider-dot-tooltip,.vue-slider-dot-tooltip-show{visibility:visible}.vue-slider-dot-tooltip-top{top:-10px;left:50%;-webkit-transform:translate(-50%,-100%);transform:translate(-50%,-100%)}.vue-slider-dot-tooltip-bottom{bottom:-10px;left:50%;-webkit-transform:translate(-50%,100%);transform:translate(-50%,100%)}.vue-slider-dot-tooltip-left{left:-10px;top:50%;-webkit-transform:translate(-100%,-50%);transform:translate(-100%,-50%)}.vue-slider-dot-tooltip-right{right:-10px;top:50%;-webkit-transform:translate(100%,-50%);transform:translate(100%,-50%)}", ""]), e2["default"] = s;
      }, 554: function(t2, e2, r2) {
        r2.r(e2);
        var n2 = r2(81), i2 = r2.n(n2), o = r2(645), a = r2.n(o), s = a()(i2());
        s.push([t2.id, ".vue-slider-marks{position:relative;width:100%;height:100%}.vue-slider-mark{position:absolute;z-index:1}.vue-slider-ltr .vue-slider-mark,.vue-slider-rtl .vue-slider-mark{width:0;height:100%;top:50%}.vue-slider-ltr .vue-slider-mark-step,.vue-slider-rtl .vue-slider-mark-step{top:0}.vue-slider-ltr .vue-slider-mark-label,.vue-slider-rtl .vue-slider-mark-label{top:100%;margin-top:10px}.vue-slider-ltr .vue-slider-mark{-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vue-slider-ltr .vue-slider-mark-step{left:0}.vue-slider-ltr .vue-slider-mark-label{left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.vue-slider-rtl .vue-slider-mark{-webkit-transform:translate(50%,-50%);transform:translate(50%,-50%)}.vue-slider-rtl .vue-slider-mark-step{right:0}.vue-slider-rtl .vue-slider-mark-label{right:50%;-webkit-transform:translateX(50%);transform:translateX(50%)}.vue-slider-btt .vue-slider-mark,.vue-slider-ttb .vue-slider-mark{width:100%;height:0;left:50%}.vue-slider-btt .vue-slider-mark-step,.vue-slider-ttb .vue-slider-mark-step{left:0}.vue-slider-btt .vue-slider-mark-label,.vue-slider-ttb .vue-slider-mark-label{left:100%;margin-left:10px}.vue-slider-btt .vue-slider-mark{-webkit-transform:translate(-50%,50%);transform:translate(-50%,50%)}.vue-slider-btt .vue-slider-mark-step{top:0}.vue-slider-btt .vue-slider-mark-label{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.vue-slider-ttb .vue-slider-mark{-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.vue-slider-ttb .vue-slider-mark-step{bottom:0}.vue-slider-ttb .vue-slider-mark-label{bottom:50%;-webkit-transform:translateY(50%);transform:translateY(50%)}.vue-slider-mark-label,.vue-slider-mark-step{position:absolute}", ""]), e2["default"] = s;
      }, 894: function(t2, e2, r2) {
        r2.r(e2);
        var n2 = r2(81), i2 = r2.n(n2), o = r2(645), a = r2.n(o), s = a()(i2());
        s.push([t2.id, ".vue-slider{position:relative;-webkit-box-sizing:content-box;box-sizing:content-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:block;-webkit-tap-highlight-color:rgba(0,0,0,0)}.vue-slider-rail{position:relative;width:100%;height:100%;-webkit-transition-property:width,height,left,right,top,bottom;transition-property:width,height,left,right,top,bottom}.vue-slider-process{position:absolute;z-index:1}", ""]), e2["default"] = s;
      }, 645: function(t2) {
        t2.exports = function(t3) {
          var e2 = [];
          return e2.toString = function() {
            return this.map(function(e3) {
              var r2 = "", n2 = "undefined" !== typeof e3[5];
              return e3[4] && (r2 += "@supports (".concat(e3[4], ") {")), e3[2] && (r2 += "@media ".concat(e3[2], " {")), n2 && (r2 += "@layer".concat(e3[5].length > 0 ? " ".concat(e3[5]) : "", " {")), r2 += t3(e3), n2 && (r2 += "}"), e3[2] && (r2 += "}"), e3[4] && (r2 += "}"), r2;
            }).join("");
          }, e2.i = function(t4, r2, n2, i2, o) {
            "string" === typeof t4 && (t4 = [[null, t4, void 0]]);
            var a = {};
            if (n2)
              for (var s = 0; s < this.length; s++) {
                var l = this[s][0];
                null != l && (a[l] = true);
              }
            for (var u = 0; u < t4.length; u++) {
              var c = [].concat(t4[u]);
              n2 && a[c[0]] || ("undefined" !== typeof o && ("undefined" === typeof c[5] || (c[1] = "@layer".concat(c[5].length > 0 ? " ".concat(c[5]) : "", " {").concat(c[1], "}")), c[5] = o), r2 && (c[2] ? (c[1] = "@media ".concat(c[2], " {").concat(c[1], "}"), c[2] = r2) : c[2] = r2), i2 && (c[4] ? (c[1] = "@supports (".concat(c[4], ") {").concat(c[1], "}"), c[4] = i2) : c[4] = "".concat(i2)), e2.push(c));
            }
          }, e2;
        };
      }, 81: function(t2) {
        t2.exports = function(t3) {
          return t3[1];
        };
      }, 744: function(t2, e2) {
        e2.Z = (t3, e3) => {
          const r2 = t3.__vccOpts || t3;
          for (const [n2, i2] of e3)
            r2[n2] = i2;
          return r2;
        };
      }, 456: function(t2, e2, r2) {
        var n2 = r2(724);
        n2.__esModule && (n2 = n2.default), "string" === typeof n2 && (n2 = [[t2.id, n2, ""]]), n2.locals && (t2.exports = n2.locals);
        var i2 = r2(402).Z;
        i2("70c8b59e", n2, true, { sourceMap: false, shadowMode: false });
      }, 560: function(t2, e2, r2) {
        var n2 = r2(554);
        n2.__esModule && (n2 = n2.default), "string" === typeof n2 && (n2 = [[t2.id, n2, ""]]), n2.locals && (t2.exports = n2.locals);
        var i2 = r2(402).Z;
        i2("63658205", n2, true, { sourceMap: false, shadowMode: false });
      }, 562: function(t2, e2, r2) {
        var n2 = r2(894);
        n2.__esModule && (n2 = n2.default), "string" === typeof n2 && (n2 = [[t2.id, n2, ""]]), n2.locals && (t2.exports = n2.locals);
        var i2 = r2(402).Z;
        i2("21173b05", n2, true, { sourceMap: false, shadowMode: false });
      }, 402: function(t2, e2, r2) {
        function n2(t3, e3) {
          for (var r3 = [], n3 = {}, i3 = 0; i3 < e3.length; i3++) {
            var o2 = e3[i3], a2 = o2[0], s2 = o2[1], l2 = o2[2], u2 = o2[3], c2 = { id: t3 + ":" + i3, css: s2, media: l2, sourceMap: u2 };
            n3[a2] ? n3[a2].parts.push(c2) : r3.push(n3[a2] = { id: a2, parts: [c2] });
          }
          return r3;
        }
        r2.d(e2, { Z: function() {
          return p;
        } });
        var i2 = "undefined" !== typeof document;
        if ("undefined" !== typeof DEBUG && DEBUG && !i2)
          throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");
        var o = {}, a = i2 && (document.head || document.getElementsByTagName("head")[0]), s = null, l = 0, u = false, c = function() {
        }, d = null, h2 = "data-vue-ssr-id", f = "undefined" !== typeof navigator && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
        function p(t3, e3, r3, i3) {
          u = r3, d = i3 || {};
          var a2 = n2(t3, e3);
          return m(a2), function(e4) {
            for (var r4 = [], i4 = 0; i4 < a2.length; i4++) {
              var s2 = a2[i4], l2 = o[s2.id];
              l2.refs--, r4.push(l2);
            }
            e4 ? (a2 = n2(t3, e4), m(a2)) : a2 = [];
            for (i4 = 0; i4 < r4.length; i4++) {
              l2 = r4[i4];
              if (0 === l2.refs) {
                for (var u2 = 0; u2 < l2.parts.length; u2++)
                  l2.parts[u2]();
                delete o[l2.id];
              }
            }
          };
        }
        function m(t3) {
          for (var e3 = 0; e3 < t3.length; e3++) {
            var r3 = t3[e3], n3 = o[r3.id];
            if (n3) {
              n3.refs++;
              for (var i3 = 0; i3 < n3.parts.length; i3++)
                n3.parts[i3](r3.parts[i3]);
              for (; i3 < r3.parts.length; i3++)
                n3.parts.push(y(r3.parts[i3]));
              n3.parts.length > r3.parts.length && (n3.parts.length = r3.parts.length);
            } else {
              var a2 = [];
              for (i3 = 0; i3 < r3.parts.length; i3++)
                a2.push(y(r3.parts[i3]));
              o[r3.id] = { id: r3.id, refs: 1, parts: a2 };
            }
          }
        }
        function v() {
          var t3 = document.createElement("style");
          return t3.type = "text/css", a.appendChild(t3), t3;
        }
        function y(t3) {
          var e3, r3, n3 = document.querySelector("style[" + h2 + '~="' + t3.id + '"]');
          if (n3) {
            if (u)
              return c;
            n3.parentNode.removeChild(n3);
          }
          if (f) {
            var i3 = l++;
            n3 = s || (s = v()), e3 = g.bind(null, n3, i3, false), r3 = g.bind(null, n3, i3, true);
          } else
            n3 = v(), e3 = k.bind(null, n3), r3 = function() {
              n3.parentNode.removeChild(n3);
            };
          return e3(t3), function(n4) {
            if (n4) {
              if (n4.css === t3.css && n4.media === t3.media && n4.sourceMap === t3.sourceMap)
                return;
              e3(t3 = n4);
            } else
              r3();
          };
        }
        var b = function() {
          var t3 = [];
          return function(e3, r3) {
            return t3[e3] = r3, t3.filter(Boolean).join("\n");
          };
        }();
        function g(t3, e3, r3, n3) {
          var i3 = r3 ? "" : n3.css;
          if (t3.styleSheet)
            t3.styleSheet.cssText = b(e3, i3);
          else {
            var o2 = document.createTextNode(i3), a2 = t3.childNodes;
            a2[e3] && t3.removeChild(a2[e3]), a2.length ? t3.insertBefore(o2, a2[e3]) : t3.appendChild(o2);
          }
        }
        function k(t3, e3) {
          var r3 = e3.css, n3 = e3.media, i3 = e3.sourceMap;
          if (n3 && t3.setAttribute("media", n3), d.ssrId && t3.setAttribute(h2, e3.id), i3 && (r3 += "\n/*# sourceURL=" + i3.sources[0] + " */", r3 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(i3)))) + " */"), t3.styleSheet)
            t3.styleSheet.cssText = r3;
          else {
            while (t3.firstChild)
              t3.removeChild(t3.firstChild);
            t3.appendChild(document.createTextNode(r3));
          }
        }
      }, 927: function(e2) {
        e2.exports = t;
      } }, r = {};
      function n(t2) {
        var i2 = r[t2];
        if (void 0 !== i2)
          return i2.exports;
        var o = r[t2] = { id: t2, exports: {} };
        return e[t2].call(o.exports, o, o.exports, n), o.exports;
      }
      !function() {
        n.n = function(t2) {
          var e2 = t2 && t2.__esModule ? function() {
            return t2["default"];
          } : function() {
            return t2;
          };
          return n.d(e2, { a: e2 }), e2;
        };
      }(), function() {
        n.d = function(t2, e2) {
          for (var r2 in e2)
            n.o(e2, r2) && !n.o(t2, r2) && Object.defineProperty(t2, r2, { enumerable: true, get: e2[r2] });
        };
      }(), function() {
        n.o = function(t2, e2) {
          return Object.prototype.hasOwnProperty.call(t2, e2);
        };
      }(), function() {
        n.r = function(t2) {
          "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
        };
      }(), function() {
        n.p = "";
      }();
      var i = {};
      return function() {
        if (n.d(i, { default: function() {
          return St;
        } }), "undefined" !== typeof window) {
          var t2 = window.document.currentScript, e2 = n(679);
          t2 = e2(), "currentScript" in document || Object.defineProperty(document, "currentScript", { get: e2 });
          var r2 = t2 && t2.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
          r2 && (n.p = r2[1]);
        }
        var o = n(927);
        function a(t3, e3, r3) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
        }
        var s = { key: 0, class: "vue-slider-marks" };
        function l(t3, e3, r3, n2, i2, l2) {
          var u2 = (0, o.resolveComponent)("vue-slider-mark"), c2 = (0, o.resolveComponent)("vue-slider-dot");
          return (0, o.openBlock)(), (0, o.createElementBlock)("div", (0, o.mergeProps)({ ref: "container", class: t3.containerClasses, style: t3.containerStyles, onClick: e3[1] || (e3[1] = function() {
            return t3.clickHandle && t3.clickHandle.apply(t3, arguments);
          }), onTouchstartPassive: e3[2] || (e3[2] = function() {
            return t3.dragStartOnProcess && t3.dragStartOnProcess.apply(t3, arguments);
          }), onMousedownPassive: e3[3] || (e3[3] = function() {
            return t3.dragStartOnProcess && t3.dragStartOnProcess.apply(t3, arguments);
          }) }, t3.$attrs), [(0, o.createElementVNode)("div", { class: "vue-slider-rail", style: (0, o.normalizeStyle)(t3.railStyle) }, [((0, o.openBlock)(true), (0, o.createElementBlock)(o.Fragment, null, (0, o.renderList)(t3.processArray, function(e4, r4) {
            return (0, o.renderSlot)(t3.$slots, "process", (0, o.normalizeProps)((0, o.guardReactiveProps)(e4)), function() {
              return [((0, o.openBlock)(), (0, o.createElementBlock)("div", { class: "vue-slider-process", key: "process-".concat(r4), style: (0, o.normalizeStyle)(e4.style) }, null, 4))];
            });
          }), 256)), t3.sliderMarks && t3.control ? ((0, o.openBlock)(), (0, o.createElementBlock)("div", s, [((0, o.openBlock)(true), (0, o.createElementBlock)(o.Fragment, null, (0, o.renderList)(t3.control.markList, function(e4, r4) {
            return (0, o.renderSlot)(t3.$slots, "mark", (0, o.normalizeProps)((0, o.guardReactiveProps)(e4)), function() {
              var n3;
              return [((0, o.openBlock)(), (0, o.createBlock)(u2, { key: "mark-".concat(r4), mark: e4, hideLabel: t3.hideLabel, style: (0, o.normalizeStyle)((n3 = {}, a(n3, t3.isHorizontal ? "height" : "width", "100%"), a(n3, t3.isHorizontal ? "width" : "height", t3.tailSize), a(n3, t3.mainDirection, "".concat(e4.pos, "%")), n3)), stepStyle: t3.stepStyle, stepActiveStyle: t3.stepActiveStyle, labelStyle: t3.labelStyle, labelActiveStyle: t3.labelActiveStyle, onPressLabel: function(e5) {
                return t3.clickable && t3.setValueByPos(e5);
              } }, { step: (0, o.withCtx)(function() {
                return [(0, o.renderSlot)(t3.$slots, "step", (0, o.normalizeProps)((0, o.guardReactiveProps)(e4)))];
              }), label: (0, o.withCtx)(function() {
                return [(0, o.renderSlot)(t3.$slots, "label", (0, o.normalizeProps)((0, o.guardReactiveProps)(e4)))];
              }), _: 2 }, 1032, ["mark", "hideLabel", "style", "stepStyle", "stepActiveStyle", "labelStyle", "labelActiveStyle", "onPressLabel"]))];
            });
          }), 256))])) : (0, o.createCommentVNode)("", true), ((0, o.openBlock)(true), (0, o.createElementBlock)(o.Fragment, null, (0, o.renderList)(t3.dots, function(r4, n3) {
            var i3;
            return (0, o.openBlock)(), (0, o.createBlock)(c2, (0, o.mergeProps)({ ref_for: true, ref: "dot-".concat(n3), key: "dot-".concat(n3), value: r4.value, disabled: r4.disabled, focus: r4.focus, "dot-style": [r4.style, r4.disabled ? r4.disabledStyle : null, r4.focus ? r4.focusStyle : null], tooltip: r4.tooltip || t3.tooltip, "tooltip-style": [t3.tooltipStyle, r4.tooltipStyle, r4.disabled ? r4.tooltipDisabledStyle : null, r4.focus ? r4.tooltipFocusStyle : null], "tooltip-formatter": Array.isArray(t3.sliderTooltipFormatter) ? t3.sliderTooltipFormatter[n3] : t3.sliderTooltipFormatter, "tooltip-placement": t3.tooltipDirections[n3], style: [t3.dotBaseStyle, (i3 = {}, a(i3, t3.mainDirection, "".concat(r4.pos, "%")), a(i3, "transition", "".concat(t3.mainDirection, " ").concat(t3.animateTime, "s")), i3)], onDragStart: function() {
              return t3.dragStart(n3);
            }, role: "slider", "aria-valuenow": r4.value, "aria-valuemin": t3.min, "aria-valuemax": t3.max, "aria-orientation": t3.isHorizontal ? "horizontal" : "vertical", tabindex: "0", onFocus: function() {
              return t3.focus(r4, n3);
            }, onBlur: e3[0] || (e3[0] = function() {
              return t3.blur();
            }) }, t3.dotAttrs), { dot: (0, o.withCtx)(function() {
              return [(0, o.renderSlot)(t3.$slots, "dot", (0, o.normalizeProps)((0, o.guardReactiveProps)(r4)))];
            }), tooltip: (0, o.withCtx)(function() {
              return [(0, o.renderSlot)(t3.$slots, "tooltip", (0, o.normalizeProps)((0, o.guardReactiveProps)(r4)))];
            }), _: 2 }, 1040, ["value", "disabled", "focus", "dot-style", "tooltip", "tooltip-style", "tooltip-formatter", "tooltip-placement", "style", "onDragStart", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "onFocus"]);
          }), 128))], 4), (0, o.renderSlot)(t3.$slots, "default", { value: t3.getValue() })], 16);
        }
        var u = ["aria-valuetext"], c = { class: "vue-slider-dot-tooltip-text" };
        function d(t3, e3, r3, n2, i2, a2) {
          return (0, o.openBlock)(), (0, o.createElementBlock)("div", { ref: "dot", class: (0, o.normalizeClass)(t3.dotClasses), "aria-valuetext": t3.tooltipValue.toString(), onMousedownPassive: e3[0] || (e3[0] = function() {
            return t3.dragStart && t3.dragStart.apply(t3, arguments);
          }), onTouchstartPassive: e3[1] || (e3[1] = function() {
            return t3.dragStart && t3.dragStart.apply(t3, arguments);
          }) }, [(0, o.renderSlot)(t3.$slots, "dot", {}, function() {
            return [(0, o.createElementVNode)("div", { class: (0, o.normalizeClass)(t3.handleClasses), style: (0, o.normalizeStyle)(t3.dotStyle) }, null, 6)];
          }), "none" !== t3.tooltip ? ((0, o.openBlock)(), (0, o.createElementBlock)("div", { key: 0, class: (0, o.normalizeClass)(t3.tooltipClasses) }, [(0, o.renderSlot)(t3.$slots, "tooltip", {}, function() {
            return [(0, o.createElementVNode)("div", { class: (0, o.normalizeClass)(t3.tooltipInnerClasses), style: (0, o.normalizeStyle)(t3.tooltipStyle) }, [(0, o.createElementVNode)("span", c, (0, o.toDisplayString)(t3.tooltipValue), 1)], 6)];
          })], 2)) : (0, o.createCommentVNode)("", true)], 42, u);
        }
        n(456);
        var h2 = (0, o.defineComponent)({ name: "VueSliderDot", emits: ["DragStart"], props: { value: { type: [String, Number], default: 0 }, tooltip: { type: String, required: true }, tooltipPlacement: { type: String, validator: function(t3) {
          return ["top", "right", "bottom", "left"].indexOf(t3) > -1;
        }, required: true }, tooltipFormatter: { type: [String, Function] }, focus: { type: Boolean, default: false }, disabled: { type: Boolean, default: false }, dotStyle: { type: Object }, tooltipStyle: { type: Object } }, computed: { dotClasses: function() {
          return ["vue-slider-dot", { "vue-slider-dot-hover": "hover" === this.tooltip || "active" === this.tooltip, "vue-slider-dot-disabled": this.disabled, "vue-slider-dot-focus": this.focus }];
        }, handleClasses: function() {
          return ["vue-slider-dot-handle", { "vue-slider-dot-handle-disabled": this.disabled, "vue-slider-dot-handle-focus": this.focus }];
        }, tooltipClasses: function() {
          return ["vue-slider-dot-tooltip", ["vue-slider-dot-tooltip-".concat(this.tooltipPlacement)], { "vue-slider-dot-tooltip-show": this.showTooltip }];
        }, tooltipInnerClasses: function() {
          return ["vue-slider-dot-tooltip-inner", ["vue-slider-dot-tooltip-inner-".concat(this.tooltipPlacement)], { "vue-slider-dot-tooltip-inner-disabled": this.disabled, "vue-slider-dot-tooltip-inner-focus": this.focus }];
        }, showTooltip: function() {
          switch (this.tooltip) {
            case "always":
              return true;
            case "none":
              return false;
            case "focus":
            case "active":
              return !!this.focus;
            default:
              return false;
          }
        }, tooltipValue: function() {
          return this.tooltipFormatter ? "string" === typeof this.tooltipFormatter ? this.tooltipFormatter.replace(/\{value\}/, String(this.value)) : this.tooltipFormatter(this.value) : this.value;
        } }, methods: { dragStart: function() {
          if (this.disabled)
            return false;
          this.$emit("DragStart");
        } } }), f = n(744);
        const p = (0, f.Z)(h2, [["render", d]]);
        var m = p;
        function v(t3, e3, r3, n2, i2, a2) {
          return (0, o.openBlock)(), (0, o.createElementBlock)("div", { class: (0, o.normalizeClass)(t3.marksClasses) }, [(0, o.renderSlot)(t3.$slots, "step", {}, function() {
            return [(0, o.createElementVNode)("div", { class: (0, o.normalizeClass)(t3.stepClasses), style: (0, o.normalizeStyle)([t3.stepStyle, t3.mark.style || {}, t3.mark.active && t3.stepActiveStyle ? t3.stepActiveStyle : {}, t3.mark.active && t3.mark.activeStyle ? t3.mark.activeStyle : {}]) }, null, 6)];
          }), t3.hideLabel ? (0, o.createCommentVNode)("", true) : (0, o.renderSlot)(t3.$slots, "label", { key: 0 }, function() {
            return [(0, o.createElementVNode)("div", { class: (0, o.normalizeClass)(t3.labelClasses), style: (0, o.normalizeStyle)([t3.labelStyle, t3.mark.labelStyle || {}, t3.mark.active && t3.labelActiveStyle ? t3.labelActiveStyle : {}, t3.mark.active && t3.mark.labelActiveStyle ? t3.mark.labelActiveStyle : {}]), onClick: e3[0] || (e3[0] = function() {
              return t3.labelClickHandle && t3.labelClickHandle.apply(t3, arguments);
            }) }, (0, o.toDisplayString)(t3.mark.label), 7)];
          })], 2);
        }
        n(560);
        var y = (0, o.defineComponent)({ name: "VueSliderMark", emits: ["PressLabel"], props: { mark: { type: Object, required: true }, hideLabel: { type: Boolean }, stepStyle: { type: Object, default: function() {
          return {};
        } }, stepActiveStyle: { type: Object, default: function() {
          return {};
        } }, labelStyle: { type: Object, default: function() {
          return {};
        } }, labelActiveStyle: { type: Object, default: function() {
          return {};
        } } }, computed: { marksClasses: function() {
          return ["vue-slider-mark", { "vue-slider-mark-active": this.mark.active }];
        }, stepClasses: function() {
          return ["vue-slider-mark-step", { "vue-slider-mark-step-active": this.mark.active }];
        }, labelClasses: function() {
          return ["vue-slider-mark-label", { "vue-slider-mark-label-active": this.mark.active }];
        } }, methods: { labelClickHandle: function(t3) {
          t3.stopPropagation(), this.$emit("PressLabel", this.mark.pos);
        } } });
        const b = (0, f.Z)(y, [["render", v]]);
        var g, k = b, S = function(t3) {
          return "number" === typeof t3 ? "".concat(t3, "px") : t3;
        }, x = function(t3) {
          var e3 = document.documentElement, r3 = document.body, n2 = t3.getBoundingClientRect(), i2 = { y: n2.top + (window.pageYOffset || e3.scrollTop) - (e3.clientTop || r3.clientTop || 0), x: n2.left + (window.pageXOffset || e3.scrollLeft) - (e3.clientLeft || r3.clientLeft || 0) };
          return i2;
        }, P = function(t3, e3, r3) {
          var n2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1, i2 = "targetTouches" in t3 ? t3.targetTouches[0] : t3, o2 = x(e3), a2 = { x: i2.pageX - o2.x, y: i2.pageY - o2.y };
          return { x: r3 ? e3.offsetWidth * n2 - a2.x : a2.x, y: r3 ? e3.offsetHeight * n2 - a2.y : a2.y };
        };
        (function(t3) {
          t3[t3["PAGE_UP"] = 33] = "PAGE_UP", t3[t3["PAGE_DOWN"] = 34] = "PAGE_DOWN", t3[t3["END"] = 35] = "END", t3[t3["HOME"] = 36] = "HOME", t3[t3["LEFT"] = 37] = "LEFT", t3[t3["UP"] = 38] = "UP", t3[t3["RIGHT"] = 39] = "RIGHT", t3[t3["DOWN"] = 40] = "DOWN";
        })(g || (g = {}));
        var w = function(t3, e3) {
          if (e3.hook) {
            var r3 = e3.hook(t3);
            if ("function" === typeof r3)
              return r3;
            if (!r3)
              return null;
          }
          switch (t3.keyCode) {
            case g.UP:
              return function(t4) {
                return "ttb" === e3.direction ? t4 - 1 : t4 + 1;
              };
            case g.RIGHT:
              return function(t4) {
                return "rtl" === e3.direction ? t4 - 1 : t4 + 1;
              };
            case g.DOWN:
              return function(t4) {
                return "ttb" === e3.direction ? t4 + 1 : t4 - 1;
              };
            case g.LEFT:
              return function(t4) {
                return "rtl" === e3.direction ? t4 + 1 : t4 - 1;
              };
            case g.END:
              return function() {
                return e3.max;
              };
            case g.HOME:
              return function() {
                return e3.min;
              };
            case g.PAGE_UP:
              return function(t4) {
                return t4 + 10;
              };
            case g.PAGE_DOWN:
              return function(t4) {
                return t4 - 10;
              };
            default:
              return null;
          }
        };
        function O(t3, e3) {
          if (!(t3 instanceof e3))
            throw new TypeError("Cannot call a class as a function");
        }
        function D(t3, e3) {
          for (var r3 = 0; r3 < e3.length; r3++) {
            var n2 = e3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
          }
        }
        function E(t3, e3, r3) {
          return e3 && D(t3.prototype, e3), r3 && D(t3, r3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
        }
        function R(t3, e3, r3) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
        }
        var A, V, j = function() {
          function t3(e3) {
            O(this, t3), R(this, "num", void 0), this.num = e3;
          }
          return E(t3, [{ key: "decimal", value: function(t4, e3) {
            var r3 = this.num, n2 = this.getDecimalLen(r3), i2 = this.getDecimalLen(t4), o2 = 0;
            switch (e3) {
              case "+":
                o2 = this.getExponent(n2, i2), this.num = (this.safeRoundUp(r3, o2) + this.safeRoundUp(t4, o2)) / o2;
                break;
              case "-":
                o2 = this.getExponent(n2, i2), this.num = (this.safeRoundUp(r3, o2) - this.safeRoundUp(t4, o2)) / o2;
                break;
              case "*":
                this.num = this.safeRoundUp(this.safeRoundUp(r3, this.getExponent(n2)), this.safeRoundUp(t4, this.getExponent(i2))) / this.getExponent(n2 + i2);
                break;
              case "/":
                o2 = this.getExponent(n2, i2), this.num = this.safeRoundUp(r3, o2) / this.safeRoundUp(t4, o2);
                break;
              case "%":
                o2 = this.getExponent(n2, i2), this.num = this.safeRoundUp(r3, o2) % this.safeRoundUp(t4, o2) / o2;
                break;
            }
            return this;
          } }, { key: "plus", value: function(t4) {
            return this.decimal(t4, "+");
          } }, { key: "minus", value: function(t4) {
            return this.decimal(t4, "-");
          } }, { key: "multiply", value: function(t4) {
            return this.decimal(t4, "*");
          } }, { key: "divide", value: function(t4) {
            return this.decimal(t4, "/");
          } }, { key: "remainder", value: function(t4) {
            return this.decimal(t4, "%");
          } }, { key: "toNumber", value: function() {
            return this.num;
          } }, { key: "getDecimalLen", value: function(t4) {
            var e3 = "".concat(t4).split("e");
            return ("".concat(e3[0]).split(".")[1] || "").length - (e3[1] ? +e3[1] : 0);
          } }, { key: "getExponent", value: function(t4, e3) {
            return Math.pow(10, void 0 !== e3 ? Math.max(t4, e3) : t4);
          } }, { key: "safeRoundUp", value: function(t4, e3) {
            return Math.round(t4 * e3);
          } }]), t3;
        }();
        function C(t3, e3) {
          return L(t3) || M(t3, e3) || H(t3, e3) || B();
        }
        function B() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function M(t3, e3) {
          var r3 = null == t3 ? null : "undefined" !== typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
          if (null != r3) {
            var n2, i2, o2 = [], a2 = true, s2 = false;
            try {
              for (r3 = r3.call(t3); !(a2 = (n2 = r3.next()).done); a2 = true)
                if (o2.push(n2.value), e3 && o2.length === e3)
                  break;
            } catch (l2) {
              s2 = true, i2 = l2;
            } finally {
              try {
                a2 || null == r3["return"] || r3["return"]();
              } finally {
                if (s2)
                  throw i2;
              }
            }
            return o2;
          }
        }
        function L(t3) {
          if (Array.isArray(t3))
            return t3;
        }
        function N(t3, e3) {
          var r3 = Object.keys(t3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(t3);
            e3 && (n2 = n2.filter(function(e4) {
              return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function z(t3) {
          for (var e3 = 1; e3 < arguments.length; e3++) {
            var r3 = null != arguments[e3] ? arguments[e3] : {};
            e3 % 2 ? N(Object(r3), true).forEach(function(e4) {
              X(t3, e4, r3[e4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r3)) : N(Object(r3)).forEach(function(e4) {
              Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r3, e4));
            });
          }
          return t3;
        }
        function I(t3) {
          return $(t3) || F(t3) || H(t3) || T();
        }
        function T() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function H(t3, e3) {
          if (t3) {
            if ("string" === typeof t3)
              return U(t3, e3);
            var r3 = Object.prototype.toString.call(t3).slice(8, -1);
            return "Object" === r3 && t3.constructor && (r3 = t3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? U(t3, e3) : void 0;
          }
        }
        function F(t3) {
          if ("undefined" !== typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
            return Array.from(t3);
        }
        function $(t3) {
          if (Array.isArray(t3))
            return U(t3);
        }
        function U(t3, e3) {
          (null == e3 || e3 > t3.length) && (e3 = t3.length);
          for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
            n2[r3] = t3[r3];
          return n2;
        }
        function _2(t3, e3) {
          if (!(t3 instanceof e3))
            throw new TypeError("Cannot call a class as a function");
        }
        function W(t3, e3) {
          for (var r3 = 0; r3 < e3.length; r3++) {
            var n2 = e3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
          }
        }
        function G(t3, e3, r3) {
          return e3 && W(t3.prototype, e3), r3 && W(t3, r3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
        }
        function X(t3, e3, r3) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
        }
        (function(t3) {
          t3[t3["VALUE"] = 1] = "VALUE", t3[t3["INTERVAL"] = 2] = "INTERVAL", t3[t3["MIN"] = 3] = "MIN", t3[t3["MAX"] = 4] = "MAX", t3[t3["ORDER"] = 5] = "ORDER";
        })(V || (V = {}));
        var q = (A = {}, X(A, V.VALUE, 'The type of the "value" is illegal'), X(A, V.INTERVAL, 'The prop "interval" is invalid, "(max - min)" must be divisible by "interval"'), X(A, V.MIN, 'The "value" must be greater than or equal to the "min".'), X(A, V.MAX, 'The "value" must be less than or equal to the "max".'), X(A, V.ORDER, 'When "order" is false, the parameters "minRange", "maxRange", "fixed", "enabled" are invalid.'), A), Z = function() {
          function t3(e3) {
            _2(this, t3), X(this, "dotsPos", []), X(this, "dotsValue", []), X(this, "data", void 0), X(this, "enableCross", void 0), X(this, "fixed", void 0), X(this, "max", void 0), X(this, "min", void 0), X(this, "interval", void 0), X(this, "minRange", void 0), X(this, "maxRange", void 0), X(this, "order", void 0), X(this, "marks", void 0), X(this, "included", void 0), X(this, "process", void 0), X(this, "adsorb", void 0), X(this, "dotOptions", void 0), X(this, "onError", void 0), X(this, "cacheRangeDir", {}), this.data = e3.data, this.max = e3.max, this.min = e3.min, this.interval = e3.interval, this.order = e3.order, this.marks = e3.marks, this.included = e3.included, this.process = e3.process, this.adsorb = e3.adsorb, this.dotOptions = e3.dotOptions, this.onError = e3.onError, this.order ? (this.minRange = e3.minRange || 0, this.maxRange = e3.maxRange || 0, this.enableCross = e3.enableCross, this.fixed = e3.fixed) : ((e3.minRange || e3.maxRange || !e3.enableCross || e3.fixed) && this.emitError(V.ORDER), this.minRange = 0, this.maxRange = 0, this.enableCross = true, this.fixed = false), this.setValue(e3.value);
          }
          return G(t3, [{ key: "setValue", value: function(t4) {
            this.setDotsValue(Array.isArray(t4) ? I(t4) : [t4], true);
          } }, { key: "setDotsValue", value: function(t4, e3) {
            this.dotsValue = t4, e3 && this.syncDotsPos();
          } }, { key: "setDotsPos", value: function(t4) {
            var e3 = this, r3 = this.order ? I(t4).sort(function(t5, e4) {
              return t5 - e4;
            }) : t4;
            this.dotsPos = r3, this.setDotsValue(r3.map(function(t5) {
              return e3.getValueByPos(t5);
            }), this.adsorb);
          } }, { key: "getValueByPos", value: function(t4) {
            var e3 = this.parsePos(t4);
            if (this.included) {
              var r3 = 100;
              this.markList.forEach(function(n2) {
                var i2 = Math.abs(n2.pos - t4);
                i2 < r3 && (r3 = i2, e3 = n2.value);
              });
            }
            return e3;
          } }, { key: "syncDotsPos", value: function() {
            var t4 = this;
            this.dotsPos = this.dotsValue.map(function(e3) {
              return t4.parseValue(e3);
            });
          } }, { key: "markList", get: function() {
            var t4 = this;
            if (!this.marks)
              return [];
            var e3 = function(e4, r3) {
              var n2 = t4.parseValue(e4);
              return z({ pos: n2, value: e4, label: e4, active: t4.isActiveByPos(n2) }, r3);
            };
            return true === this.marks ? this.getValues().map(function(t5) {
              return e3(t5);
            }) : "[object Object]" === Object.prototype.toString.call(this.marks) ? Object.keys(this.marks).sort(function(t5, e4) {
              return +t5 - +e4;
            }).map(function(r3) {
              var n2 = t4.marks[r3];
              return e3(r3, "string" !== typeof n2 ? n2 : { label: n2 });
            }) : Array.isArray(this.marks) ? this.marks.map(function(t5) {
              return e3(t5);
            }) : "function" === typeof this.marks ? this.getValues().map(function(e4) {
              return { value: e4, result: t4.marks(e4) };
            }).filter(function(t5) {
              var e4 = t5.result;
              return !!e4;
            }).map(function(t5) {
              var r3 = t5.value, n2 = t5.result;
              return e3(r3, n2);
            }) : [];
          } }, { key: "getRecentDot", value: function(t4) {
            var e3 = this.dotsPos.map(function(e4) {
              return Math.abs(e4 - t4);
            });
            return e3.indexOf(Math.min.apply(Math, I(e3)));
          } }, { key: "getIndexByValue", value: function(t4) {
            return this.data ? this.data.indexOf(t4) : new j(+t4).minus(this.min).divide(this.interval).toNumber();
          } }, { key: "getValueByIndex", value: function(t4) {
            return t4 < 0 ? t4 = 0 : t4 > this.total && (t4 = this.total), this.data ? this.data[t4] : new j(t4).multiply(this.interval).plus(this.min).toNumber();
          } }, { key: "setDotPos", value: function(t4, e3) {
            t4 = this.getValidPos(t4, e3).pos;
            var r3 = t4 - this.dotsPos[e3];
            if (r3) {
              var n2 = new Array(this.dotsPos.length);
              this.fixed ? n2 = this.getFixedChangePosArr(r3, e3) : this.minRange || this.maxRange ? n2 = this.getLimitRangeChangePosArr(t4, r3, e3) : n2[e3] = r3, this.setDotsPos(this.dotsPos.map(function(t5, e4) {
                return t5 + (n2[e4] || 0);
              }));
            }
          } }, { key: "getFixedChangePosArr", value: function(t4, e3) {
            var r3 = this;
            return this.dotsPos.forEach(function(n2, i2) {
              if (i2 !== e3) {
                var o2 = r3.getValidPos(n2 + t4, i2), a2 = o2.pos, s2 = o2.inRange;
                s2 || (t4 = Math.min(Math.abs(a2 - n2), Math.abs(t4)) * (t4 < 0 ? -1 : 1));
              }
            }), this.dotsPos.map(function(e4) {
              return t4;
            });
          } }, { key: "getLimitRangeChangePosArr", value: function(t4, e3, r3) {
            var n2 = this, i2 = [{ index: r3, changePos: e3 }], o2 = e3;
            return [this.minRange, this.maxRange].forEach(function(a2, s2) {
              if (!a2)
                return false;
              var l2 = 0 === s2, u2 = e3 > 0, c2 = 0;
              c2 = l2 ? u2 ? 1 : -1 : u2 ? -1 : 1;
              var d2 = function(t5, e4) {
                var r4 = Math.abs(t5 - e4);
                return l2 ? r4 < n2.minRangeDir : r4 > n2.maxRangeDir;
              }, h3 = r3 + c2, f2 = n2.dotsPos[h3], p2 = t4;
              while (n2.isPos(f2) && d2(f2, p2)) {
                var m2 = n2.getValidPos(f2 + o2, h3), v2 = m2.pos;
                i2.push({ index: h3, changePos: v2 - f2 }), h3 += c2, p2 = v2, f2 = n2.dotsPos[h3];
              }
            }), this.dotsPos.map(function(t5, e4) {
              var r4 = i2.filter(function(t6) {
                return t6.index === e4;
              });
              return r4.length ? r4[0].changePos : 0;
            });
          } }, { key: "isPos", value: function(t4) {
            return "number" === typeof t4;
          } }, { key: "getValidPos", value: function(t4, e3) {
            var r3 = this.valuePosRange[e3], n2 = true;
            return t4 < r3[0] ? (t4 = r3[0], n2 = false) : t4 > r3[1] && (t4 = r3[1], n2 = false), { pos: t4, inRange: n2 };
          } }, { key: "parseValue", value: function(t4) {
            if (this.data)
              t4 = this.data.indexOf(t4);
            else if ("number" === typeof t4 || "string" === typeof t4) {
              if (t4 = +t4, t4 < this.min)
                return this.emitError(V.MIN), 0;
              if (t4 > this.max)
                return this.emitError(V.MAX), 0;
              if ("number" !== typeof t4 || t4 !== t4)
                return this.emitError(V.VALUE), 0;
              t4 = new j(t4).minus(this.min).divide(this.interval).toNumber();
            }
            var e3 = new j(t4).multiply(this.gap).toNumber();
            return e3 < 0 ? 0 : e3 > 100 ? 100 : e3;
          } }, { key: "parsePos", value: function(t4) {
            var e3 = Math.round(t4 / this.gap);
            return this.getValueByIndex(e3);
          } }, { key: "isActiveByPos", value: function(t4) {
            return this.processArray.some(function(e3) {
              var r3 = C(e3, 2), n2 = r3[0], i2 = r3[1];
              return t4 >= n2 && t4 <= i2;
            });
          } }, { key: "getValues", value: function() {
            if (this.data)
              return this.data;
            for (var t4 = [], e3 = 0; e3 <= this.total; e3++)
              t4.push(new j(e3).multiply(this.interval).plus(this.min).toNumber());
            return t4;
          } }, { key: "getRangeDir", value: function(t4) {
            return t4 ? new j(t4).divide(new j(this.data ? this.data.length - 1 : this.max).minus(this.data ? 0 : this.min).toNumber()).multiply(100).toNumber() : 100;
          } }, { key: "emitError", value: function(t4) {
            this.onError && this.onError(t4, q[t4]);
          } }, { key: "processArray", get: function() {
            if (this.process) {
              if ("function" === typeof this.process)
                return this.process(this.dotsPos);
              if (1 === this.dotsPos.length)
                return [[0, this.dotsPos[0]]];
              if (this.dotsPos.length > 1)
                return [[Math.min.apply(Math, I(this.dotsPos)), Math.max.apply(Math, I(this.dotsPos))]];
            }
            return [];
          } }, { key: "total", get: function() {
            var t4 = 0;
            return t4 = this.data ? this.data.length - 1 : new j(this.max).minus(this.min).divide(this.interval).toNumber(), t4 - Math.floor(t4) !== 0 ? (this.emitError(V.INTERVAL), 0) : t4;
          } }, { key: "gap", get: function() {
            return 100 / this.total;
          } }, { key: "minRangeDir", get: function() {
            return this.cacheRangeDir[this.minRange] ? this.cacheRangeDir[this.minRange] : this.cacheRangeDir[this.minRange] = this.getRangeDir(this.minRange);
          } }, { key: "maxRangeDir", get: function() {
            return this.cacheRangeDir[this.maxRange] ? this.cacheRangeDir[this.maxRange] : this.cacheRangeDir[this.maxRange] = this.getRangeDir(this.maxRange);
          } }, { key: "getDotRange", value: function(t4, e3, r3) {
            if (!this.dotOptions)
              return r3;
            var n2 = Array.isArray(this.dotOptions) ? this.dotOptions[t4] : this.dotOptions;
            return n2 && void 0 !== n2[e3] ? this.parseValue(n2[e3]) : r3;
          } }, { key: "valuePosRange", get: function() {
            var t4 = this, e3 = this.dotsPos, r3 = [];
            return e3.forEach(function(n2, i2) {
              r3.push([Math.max(t4.minRange ? t4.minRangeDir * i2 : 0, t4.enableCross ? 0 : e3[i2 - 1] || 0, t4.getDotRange(i2, "min", 0)), Math.min(t4.minRange ? 100 - t4.minRangeDir * (e3.length - 1 - i2) : 100, t4.enableCross ? 100 : e3[i2 + 1] || 100, t4.getDotRange(i2, "max", 100))]);
            }), r3;
          } }, { key: "dotsIndex", get: function() {
            var t4 = this;
            return this.dotsValue.map(function(e3) {
              return t4.getIndexByValue(e3);
            });
          } }]), t3;
        }();
        function Y(t3, e3) {
          if (!(t3 instanceof e3))
            throw new TypeError("Cannot call a class as a function");
        }
        function K(t3, e3) {
          for (var r3 = 0; r3 < e3.length; r3++) {
            var n2 = e3[r3];
            n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(t3, n2.key, n2);
          }
        }
        function J(t3, e3, r3) {
          return e3 && K(t3.prototype, e3), r3 && K(t3, r3), Object.defineProperty(t3, "prototype", { writable: false }), t3;
        }
        function Q(t3, e3, r3) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
        }
        var tt = function() {
          function t3(e3) {
            Y(this, t3), Q(this, "map", void 0), Q(this, "states", 0), this.map = e3;
          }
          return J(t3, [{ key: "add", value: function(t4) {
            this.states |= t4;
          } }, { key: "delete", value: function(t4) {
            this.states &= ~t4;
          } }, { key: "toggle", value: function(t4) {
            this.has(t4) ? this.delete(t4) : this.add(t4);
          } }, { key: "has", value: function(t4) {
            return !!(this.states & t4);
          } }]), t3;
        }();
        n(562);
        function et(t3) {
          return it(t3) || nt(t3) || dt(t3) || rt();
        }
        function rt() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function nt(t3) {
          if ("undefined" !== typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"])
            return Array.from(t3);
        }
        function it(t3) {
          if (Array.isArray(t3))
            return ht(t3);
        }
        function ot(t3) {
          return ot = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t4) {
            return typeof t4;
          } : function(t4) {
            return t4 && "function" == typeof Symbol && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4;
          }, ot(t3);
        }
        function at(t3, e3) {
          var r3 = Object.keys(t3);
          if (Object.getOwnPropertySymbols) {
            var n2 = Object.getOwnPropertySymbols(t3);
            e3 && (n2 = n2.filter(function(e4) {
              return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
            })), r3.push.apply(r3, n2);
          }
          return r3;
        }
        function st(t3) {
          for (var e3 = 1; e3 < arguments.length; e3++) {
            var r3 = null != arguments[e3] ? arguments[e3] : {};
            e3 % 2 ? at(Object(r3), true).forEach(function(e4) {
              lt(t3, e4, r3[e4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t3, Object.getOwnPropertyDescriptors(r3)) : at(Object(r3)).forEach(function(e4) {
              Object.defineProperty(t3, e4, Object.getOwnPropertyDescriptor(r3, e4));
            });
          }
          return t3;
        }
        function lt(t3, e3, r3) {
          return e3 in t3 ? Object.defineProperty(t3, e3, { value: r3, enumerable: true, configurable: true, writable: true }) : t3[e3] = r3, t3;
        }
        function ut(t3, e3) {
          return pt(t3) || ft(t3, e3) || dt(t3, e3) || ct();
        }
        function ct() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function dt(t3, e3) {
          if (t3) {
            if ("string" === typeof t3)
              return ht(t3, e3);
            var r3 = Object.prototype.toString.call(t3).slice(8, -1);
            return "Object" === r3 && t3.constructor && (r3 = t3.constructor.name), "Map" === r3 || "Set" === r3 ? Array.from(t3) : "Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? ht(t3, e3) : void 0;
          }
        }
        function ht(t3, e3) {
          (null == e3 || e3 > t3.length) && (e3 = t3.length);
          for (var r3 = 0, n2 = new Array(e3); r3 < e3; r3++)
            n2[r3] = t3[r3];
          return n2;
        }
        function ft(t3, e3) {
          var r3 = null == t3 ? null : "undefined" !== typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
          if (null != r3) {
            var n2, i2, o2 = [], a2 = true, s2 = false;
            try {
              for (r3 = r3.call(t3); !(a2 = (n2 = r3.next()).done); a2 = true)
                if (o2.push(n2.value), e3 && o2.length === e3)
                  break;
            } catch (l2) {
              s2 = true, i2 = l2;
            } finally {
              try {
                a2 || null == r3["return"] || r3["return"]();
              } finally {
                if (s2)
                  throw i2;
              }
            }
            return o2;
          }
        }
        function pt(t3) {
          if (Array.isArray(t3))
            return t3;
        }
        var mt = { None: 0, Drag: 2, Focus: 4 }, vt = 4, yt = (0, o.defineComponent)({ name: "VueSlider", components: { VueSliderDot: m, VueSliderMark: k }, emits: ["change", "drag-start", "dragging", "drag-end", "error", "update:modelValue"], data: function() {
          return { control: null, states: new tt(mt), scale: 1, focusDotIndex: 0 };
        }, props: { modelValue: { type: [Number, String, Array], default: 0 }, silent: { type: Boolean, default: false }, direction: { type: String, default: "ltr", validator: function(t3) {
          return ["ltr", "rtl", "ttb", "btt"].indexOf(t3) > -1;
        } }, width: { type: [Number, String] }, height: { type: [Number, String] }, dotSize: { type: [Number, Array], default: 14 }, contained: { type: Boolean, default: false }, min: { type: Number, default: 0 }, max: { type: Number, default: 100 }, interval: { type: Number, default: 1 }, disabled: { type: Boolean, default: false }, clickable: { type: Boolean, default: true }, dragOnClick: { type: Boolean, default: false }, duration: { type: Number, default: 0.5 }, data: { type: [Object, Array] }, dataValue: { type: String, default: "value" }, dataLabel: { type: String, default: "label" }, lazy: { type: Boolean, default: false }, tooltip: { type: String, default: "active", validator: function(t3) {
          return ["none", "always", "focus", "hover", "active"].indexOf(t3) > -1;
        } }, tooltipPlacement: { type: [String, Array], validator: function(t3) {
          return (Array.isArray(t3) ? t3 : [t3]).every(function(t4) {
            return ["top", "right", "bottom", "left"].indexOf(t4) > -1;
          });
        } }, tooltipFormatter: { type: [String, Array, Function] }, useKeyboard: { type: Boolean, default: true }, keydownHook: { type: Function }, enableCross: { type: Boolean, default: true }, fixed: { type: Boolean, default: false }, order: { type: Boolean, default: true }, minRange: { type: Number }, maxRange: { type: Number }, marks: { type: [Boolean, Object, Array, Function], default: false }, process: { type: [Boolean, Function], default: true }, zoom: { type: Number }, included: { type: Boolean }, adsorb: { type: Boolean }, hideLabel: { type: Boolean }, dotOptions: { type: [Object, Array] }, dotAttrs: { type: Object }, railStyle: { type: Object }, processStyle: { type: Object }, dotStyle: { type: Object }, tooltipStyle: { type: Object }, stepStyle: { type: Object }, stepActiveStyle: { type: Object }, labelStyle: { type: Object }, labelActiveStyle: { type: Object } }, computed: { isHorizontal: function() {
          return "ltr" === this.direction || "rtl" === this.direction;
        }, isReverse: function() {
          return "rtl" === this.direction || "btt" === this.direction;
        }, tailSize: function() {
          return S((this.isHorizontal ? this.height : this.width) || vt);
        }, containerClasses: function() {
          return ["vue-slider", ["vue-slider-".concat(this.direction)], { "vue-slider-disabled": this.disabled }];
        }, containerStyles: function() {
          var t3 = Array.isArray(this.dotSize) ? this.dotSize : [this.dotSize, this.dotSize], e3 = ut(t3, 2), r3 = e3[0], n2 = e3[1], i2 = this.width ? S(this.width) : this.isHorizontal ? "auto" : S(vt), o2 = this.height ? S(this.height) : this.isHorizontal ? S(vt) : "auto";
          return { padding: this.contained ? "".concat(n2 / 2, "px ").concat(r3 / 2, "px") : this.isHorizontal ? "".concat(n2 / 2, "px 0") : "0 ".concat(r3 / 2, "px"), width: i2, height: o2 };
        }, processArray: function() {
          var t3 = this;
          return this.control.processArray.map(function(e3, r3) {
            var n2, i2 = ut(e3, 3), o2 = i2[0], a2 = i2[1], s2 = i2[2];
            if (o2 > a2) {
              var l2 = [a2, o2];
              o2 = l2[0], a2 = l2[1];
            }
            var u2 = t3.isHorizontal ? "width" : "height";
            return { start: o2, end: a2, index: r3, style: st(st((n2 = {}, lt(n2, t3.isHorizontal ? "height" : "width", "100%"), lt(n2, t3.isHorizontal ? "top" : "left", 0), lt(n2, t3.mainDirection, "".concat(o2, "%")), lt(n2, u2, "".concat(a2 - o2, "%")), lt(n2, "transitionProperty", "".concat(u2, ",").concat(t3.mainDirection)), lt(n2, "transitionDuration", "".concat(t3.animateTime, "s")), n2), t3.processStyle), s2) };
          });
        }, dotBaseStyle: function() {
          var t3, e3 = Array.isArray(this.dotSize) ? this.dotSize : [this.dotSize, this.dotSize], r3 = ut(e3, 2), n2 = r3[0], i2 = r3[1];
          return t3 = this.isHorizontal ? lt({ transform: "translate(".concat(this.isReverse ? "50%" : "-50%", ", -50%)"), WebkitTransform: "translate(".concat(this.isReverse ? "50%" : "-50%", ", -50%)"), top: "50%" }, "ltr" === this.direction ? "left" : "right", "0") : lt({ transform: "translate(-50%, ".concat(this.isReverse ? "50%" : "-50%", ")"), WebkitTransform: "translate(-50%, ".concat(this.isReverse ? "50%" : "-50%", ")"), left: "50%" }, "btt" === this.direction ? "bottom" : "top", "0"), st({ width: "".concat(n2, "px"), height: "".concat(i2, "px") }, t3);
        }, mainDirection: function() {
          switch (this.direction) {
            case "ltr":
              return "left";
            case "rtl":
              return "right";
            case "btt":
              return "bottom";
            case "ttb":
              return "top";
            default:
              return "left";
          }
        }, tooltipDirections: function() {
          var t3 = this.tooltipPlacement || (this.isHorizontal ? "top" : "left");
          return Array.isArray(t3) ? t3 : this.dots.map(function() {
            return t3;
          });
        }, dots: function() {
          var t3 = this;
          return this.control.dotsPos.map(function(e3, r3) {
            return st({ pos: e3, index: r3, value: t3.control.dotsValue[r3], focus: t3.states.has(mt.Focus) && t3.focusDotIndex === r3, disabled: t3.disabled, style: t3.dotStyle }, (Array.isArray(t3.dotOptions) ? t3.dotOptions[r3] : t3.dotOptions) || {});
          });
        }, animateTime: function() {
          return this.states.has(mt.Drag) ? 0 : this.duration;
        }, canSort: function() {
          return this.order && !this.minRange && !this.maxRange && !this.fixed && this.enableCross;
        }, sliderData: function() {
          var t3 = this;
          return this.isObjectArrayData(this.data) ? this.data.map(function(e3) {
            return e3[t3.dataValue];
          }) : this.isObjectData(this.data) ? Object.keys(this.data) : this.data;
        }, sliderMarks: function() {
          var t3 = this;
          return this.marks ? this.marks : this.isObjectArrayData(this.data) ? function(e3) {
            var r3 = { label: e3 };
            return t3.data.some(function(n2) {
              return n2[t3.dataValue] === e3 && (r3.label = n2[t3.dataLabel], true);
            }), r3;
          } : this.isObjectData(this.data) ? this.data : void 0;
        }, sliderTooltipFormatter: function() {
          var t3 = this;
          if (this.tooltipFormatter)
            return this.tooltipFormatter;
          if (this.isObjectArrayData(this.data))
            return function(e4) {
              var r3 = "" + e4;
              return t3.data.some(function(n2) {
                return n2[t3.dataValue] === e4 && (r3 = n2[t3.dataLabel], true);
              }), r3;
            };
          if (this.isObjectData(this.data)) {
            var e3 = this.data;
            return function(t4) {
              return e3[t4];
            };
          }
        }, isNotSync: function() {
          var t3 = this.control.dotsValue;
          return Array.isArray(this.modelValue) ? this.modelValue.length !== t3.length || this.modelValue.some(function(e3, r3) {
            return e3 !== t3[r3];
          }) : this.modelValue !== t3[0];
        }, dragRange: function() {
          var t3 = this.dots[this.focusDotIndex - 1], e3 = this.dots[this.focusDotIndex + 1];
          return [t3 ? t3.pos : -1 / 0, e3 ? e3.pos : 1 / 0];
        } }, watch: { modelValue: function() {
          this.control && !this.states.has(mt.Drag) && this.isNotSync && this.control.setValue(this.modelValue);
        } }, methods: { isObjectData: function(t3) {
          return !!t3 && "[object Object]" === Object.prototype.toString.call(t3);
        }, isObjectArrayData: function(t3) {
          return !!t3 && Array.isArray(t3) && t3.length > 0 && "object" === ot(t3[0]);
        }, bindEvent: function() {
          document.addEventListener("touchmove", this.dragMove, { passive: false }), document.addEventListener("touchend", this.dragEnd, { passive: false }), document.addEventListener("mousedown", this.blurHandle), document.addEventListener("mousemove", this.dragMove), document.addEventListener("mouseup", this.dragEnd), document.addEventListener("mouseleave", this.dragEnd), document.addEventListener("keydown", this.keydownHandle);
        }, unbindEvent: function() {
          document.removeEventListener("touchmove", this.dragMove), document.removeEventListener("touchend", this.dragEnd), document.removeEventListener("mousedown", this.blurHandle), document.removeEventListener("mousemove", this.dragMove), document.removeEventListener("mouseup", this.dragEnd), document.removeEventListener("mouseleave", this.dragEnd), document.removeEventListener("keydown", this.keydownHandle);
        }, setScale: function() {
          this.scale = new j(Math.floor(this.isHorizontal ? this.$el.offsetWidth : this.$el.offsetHeight)).multiply(this.zoom || 1).divide(100).toNumber();
        }, initControl: function() {
          var t3 = this;
          this.control = new Z({ value: this.modelValue, data: this.sliderData, enableCross: this.enableCross, fixed: this.fixed, max: this.max, min: this.min, interval: this.interval, minRange: this.minRange, maxRange: this.maxRange, order: this.order, marks: this.sliderMarks, included: this.included, process: this.process, adsorb: this.adsorb, dotOptions: this.dotOptions, onError: this.emitError }), ["data", "enableCross", "fixed", "max", "min", "interval", "minRange", "maxRange", "order", "marks", "process", "adsorb", "included", "dotOptions"].forEach(function(e3) {
            t3.$watch(e3, function(r3) {
              if ("data" === e3 && Array.isArray(t3.control.data) && Array.isArray(r3) && t3.control.data.length === r3.length && r3.every(function(e4, r4) {
                return e4 === t3.control.data[r4];
              }))
                return false;
              switch (e3) {
                case "data":
                case "dataLabel":
                case "dataValue":
                  t3.control.data = t3.sliderData;
                  break;
                case "mark":
                  t3.control.marks = t3.sliderMarks;
                  break;
                default:
                  t3.control[e3] = r3;
              }
              ["data", "max", "min", "interval"].indexOf(e3) > -1 && t3.control.syncDotsPos();
            });
          });
        }, syncValueByPos: function() {
          var t3 = this.control.dotsValue;
          if (this.isDiff(t3, Array.isArray(this.modelValue) ? this.modelValue : [this.modelValue])) {
            var e3 = 1 === t3.length ? t3[0] : et(t3);
            this.$emit("change", e3, this.focusDotIndex), this.$emit("update:modelValue", e3);
          }
        }, isDiff: function(t3, e3) {
          return t3.length !== e3.length || t3.some(function(t4, r3) {
            return t4 !== e3[r3];
          });
        }, emitError: function(t3, e3) {
          this.silent || console.error("[VueSlider error]: ".concat(e3)), this.$emit("error", t3, e3);
        }, dragStartOnProcess: function(t3) {
          if (this.dragOnClick) {
            this.setScale();
            var e3 = this.getPosByEvent(t3), r3 = this.control.getRecentDot(e3);
            if (this.dots[r3].disabled)
              return;
            this.dragStart(r3), this.control.setDotPos(e3, this.focusDotIndex), this.lazy || this.syncValueByPos();
          }
        }, dragStart: function(t3) {
          this.focusDotIndex = t3, this.setScale(), this.states.add(mt.Drag), this.states.add(mt.Focus), this.$emit("drag-start", this.focusDotIndex);
        }, dragMove: function(t3) {
          if (!this.states.has(mt.Drag))
            return false;
          t3.preventDefault();
          var e3 = this.getPosByEvent(t3);
          this.isCrossDot(e3), this.control.setDotPos(e3, this.focusDotIndex), this.lazy || this.syncValueByPos();
          var r3 = this.control.dotsValue;
          this.$emit("dragging", 1 === r3.length ? r3[0] : et(r3), this.focusDotIndex);
        }, isCrossDot: function(t3) {
          if (this.canSort) {
            var e3 = this.focusDotIndex, r3 = t3;
            if (r3 > this.dragRange[1] ? (r3 = this.dragRange[1], this.focusDotIndex++) : r3 < this.dragRange[0] && (r3 = this.dragRange[0], this.focusDotIndex--), e3 !== this.focusDotIndex) {
              var n2 = this.$refs["dot-".concat(this.focusDotIndex)];
              n2 && n2.$el && n2.$el.focus(), this.control.setDotPos(r3, e3);
            }
          }
        }, dragEnd: function(t3) {
          var e3 = this;
          if (!this.states.has(mt.Drag))
            return false;
          setTimeout(function() {
            e3.lazy && e3.syncValueByPos(), e3.included && e3.isNotSync ? e3.control.setValue(e3.modelValue) : e3.control.syncDotsPos(), e3.states.delete(mt.Drag), e3.useKeyboard && !("targetTouches" in t3) || e3.states.delete(mt.Focus), e3.$emit("drag-end", e3.focusDotIndex);
          });
        }, blurHandle: function(t3) {
          if (!this.states.has(mt.Focus) || !this.$refs.container || this.$refs.container.contains(t3.target))
            return false;
          this.states.delete(mt.Focus);
        }, clickHandle: function(t3) {
          if (!this.clickable || this.disabled)
            return false;
          if (!this.states.has(mt.Drag)) {
            this.setScale();
            var e3 = this.getPosByEvent(t3);
            this.setValueByPos(e3);
          }
        }, focus: function(t3) {
          var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
          t3.disabled || (this.states.add(mt.Focus), this.focusDotIndex = e3);
        }, blur: function() {
          this.states.delete(mt.Focus);
        }, getValue: function() {
          var t3 = this.control.dotsValue;
          return 1 === t3.length ? t3[0] : t3;
        }, getIndex: function() {
          var t3 = this.control.dotsIndex;
          return 1 === t3.length ? t3[0] : t3;
        }, setValue: function(t3) {
          this.control.setValue(Array.isArray(t3) ? et(t3) : [t3]), this.syncValueByPos();
        }, setIndex: function(t3) {
          var e3 = this, r3 = Array.isArray(t3) ? t3.map(function(t4) {
            return e3.control.getValueByIndex(t4);
          }) : this.control.getValueByIndex(t3);
          this.setValue(r3);
        }, setValueByPos: function(t3) {
          var e3 = this, r3 = this.control.getRecentDot(t3);
          if (this.disabled || this.dots[r3].disabled)
            return false;
          this.focusDotIndex = r3, this.control.setDotPos(t3, r3), this.syncValueByPos(), this.useKeyboard && this.states.add(mt.Focus), setTimeout(function() {
            e3.included && e3.isNotSync ? e3.control.setValue(e3.modelValue) : e3.control.syncDotsPos();
          });
        }, keydownHandle: function(t3) {
          var e3 = this;
          if (!this.useKeyboard || !this.states.has(mt.Focus))
            return false;
          var r3 = this.included && this.marks, n2 = w(t3, { direction: this.direction, max: r3 ? this.control.markList.length - 1 : this.control.total, min: 0, hook: this.keydownHook });
          if (n2) {
            t3.preventDefault();
            var i2 = -1, o2 = 0;
            r3 ? (this.control.markList.some(function(t4, r4) {
              return t4.value === e3.control.dotsValue[e3.focusDotIndex] && (i2 = n2(r4), true);
            }), i2 < 0 ? i2 = 0 : i2 > this.control.markList.length - 1 && (i2 = this.control.markList.length - 1), o2 = this.control.markList[i2].pos) : (i2 = n2(this.control.getIndexByValue(this.control.dotsValue[this.focusDotIndex])), o2 = this.control.parseValue(this.control.getValueByIndex(i2))), this.isCrossDot(o2), this.control.setDotPos(o2, this.focusDotIndex), this.syncValueByPos();
          }
        }, getPosByEvent: function(t3) {
          return P(t3, this.$el, this.isReverse, this.zoom)[this.isHorizontal ? "x" : "y"] / this.scale;
        }, renderSlot: function(t3, e3, r3) {
          var n2 = this.$slots[t3];
          return n2 ? n2(e3) : r3;
        } }, created: function() {
          this.initControl();
        }, mounted: function() {
          this.bindEvent();
        }, beforeUnmount: function() {
          this.unbindEvent();
        } });
        const bt = (0, f.Z)(yt, [["render", l]]);
        var gt = bt;
        gt.VueSliderMark = k, gt.VueSliderDot = m;
        var kt = gt, St = kt;
      }(), i = i["default"], i;
    }();
  });
})(vueSliderComponent_umd_min);
var VueSlider = /* @__PURE__ */ getDefaultExportFromCjs(vueSliderComponent_umd_min.exports);
var galleryAudioPlayerUiMobile_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$e = {
  name: "audioPlayerUiDesktop",
  mixins: [makeCoverUrl],
  components: {
    VueSlider
  },
  data: function() {
    return {
      store: this.$store.state
    };
  },
  computed: {
    cover() {
      return this.makeCoverUrl(this.$store.getters.audioPlayerBook.cover, 500);
    },
    progress: {
      get() {
        return this.store.audioPlayer.progress;
      },
      set(value) {
        this.$compEmitter.emit("audio-player-scrubbed", { target: { value } });
      }
    }
  },
  mounted() {
    this.$store.commit("prop", { key: "preventScrolling", value: true });
  },
  beforeUnmount() {
    this.$store.commit("prop", { key: "preventScrolling", value: false });
  },
  methods: {
    swipeHandler() {
      this.$store.commit("prop", { key: "showMobilePlayer", value: false });
    }
  }
};
const _withScopeId$3 = (n) => (pushScopeId("data-v-457a3000"), n = n(), popScopeId(), n);
const _hoisted_1$x = { id: "audio-player" };
const _hoisted_2$u = { class: "inner-wrap" };
const _hoisted_3$s = { class: "cover-wrap" };
const _hoisted_4$6 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "close-instructions" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "text" }, " swipe down to close ")
], -1));
const _hoisted_5$5 = { class: "cover-inner-wrap" };
const _hoisted_6$4 = ["src"];
const _hoisted_7$4 = { class: "bottom" };
const _hoisted_8$3 = { class: "player-timeline" };
const _hoisted_9$3 = { class: "duration-wrapper" };
const _hoisted_10$3 = {
  key: 0,
  class: "time-display"
};
const _hoisted_11$2 = {
  key: 1,
  class: "time-display"
};
const _hoisted_12$2 = { class: "player-buttons" };
const _hoisted_13$2 = { class: "play-pause" };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vue_slider = resolveComponent("vue-slider");
  const _component_ic_baseline_replay_30 = __unplugin_components_3$4;
  const _component_ic_sharp_play_circle_filled = __unplugin_components_1$9;
  const _component_ic_sharp_pause_circle_filled = __unplugin_components_2$3;
  const _component_ic_baseline_forward_30 = __unplugin_components_4$4;
  const _directive_touch = resolveDirective("touch");
  return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$x, [
    createBaseVNode("div", _hoisted_2$u, [
      createBaseVNode("div", _hoisted_3$s, [
        _hoisted_4$6,
        createBaseVNode("div", _hoisted_5$5, [
          createBaseVNode("img", {
            class: "book-cover",
            src: $options.cover,
            alt: "",
            draggable: "false"
          }, null, 8, _hoisted_6$4)
        ]),
        createBaseVNode("div", {
          class: "book-cover-bg",
          style: normalizeStyle({ backgroundImage: `url('${$options.cover}')` })
        }, null, 4)
      ]),
      createBaseVNode("div", _hoisted_7$4, [
        createBaseVNode("div", _hoisted_8$3, [
          createVNode(_component_vue_slider, {
            style: { "width": "100%" },
            modelValue: $options.progress,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.progress = $event),
            tooltip: "none"
          }, null, 8, ["modelValue"]),
          createBaseVNode("div", _hoisted_9$3, [
            _ctx.store.audioPlayer.timeDisplay ? (openBlock(), createElementBlock("div", _hoisted_10$3, toDisplayString(_ctx.store.audioPlayer.timeDisplay), 1)) : createCommentVNode("", true),
            _ctx.store.audioPlayer.timeDisplayLeft ? (openBlock(), createElementBlock("div", _hoisted_11$2, "-" + toDisplayString(_ctx.store.audioPlayer.timeDisplayLeft), 1)) : createCommentVNode("", true)
          ])
        ]),
        _ctx.$store.getters.audioPlayerTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "book",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.openBook && _ctx.openBook(...args))
        }, [
          createBaseVNode("span", null, toDisplayString(_ctx.$store.getters.audioPlayerTitle), 1)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_12$2, [
          createBaseVNode("div", {
            class: "back",
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$compEmitter.emit("audio-player-seek-back"))
          }, [
            createVNode(_component_ic_baseline_replay_30)
          ]),
          createBaseVNode("div", _hoisted_13$2, [
            !_ctx.$store.state.audioPlayer.playing ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "play",
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$compEmitter.emit("audio-player-play"))
            }, [
              createVNode(_component_ic_sharp_play_circle_filled)
            ])) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: "pause",
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$compEmitter.emit("audio-player-pause"))
            }, [
              createVNode(_component_ic_sharp_pause_circle_filled)
            ]))
          ]),
          createBaseVNode("div", {
            class: "forward",
            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$compEmitter.emit("audio-player-seek-forward"))
          }, [
            createVNode(_component_ic_baseline_forward_30)
          ])
        ])
      ])
    ])
  ])), [
    [vShow, _ctx.store.audioPlayer.audio],
    [
      _directive_touch,
      $options.swipeHandler,
      "swipe",
      { bottom: true }
    ],
    [
      _directive_touch,
      $options.swipeHandler,
      "swipe",
      { top: true }
    ]
  ]);
}
var __unplugin_components_3$3 = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__scopeId", "data-v-457a3000"]]);
const _hoisted_1$w = {
  viewBox: "0 0 320 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$t = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M285.476 272.971L91.132 467.314c-9.373 9.373-24.569 9.373-33.941 0l-22.667-22.667c-9.357-9.357-9.375-24.522-.04-33.901L188.505 256L34.484 101.255c-9.335-9.379-9.317-24.544.04-33.901l22.667-22.667c9.373-9.373 24.569-9.373 33.941 0L285.475 239.03c9.373 9.372 9.373 24.568.001 33.941z"
}, null, -1);
const _hoisted_3$r = [
  _hoisted_2$t
];
function render$k(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$w, _hoisted_3$r);
}
var __unplugin_components_0$a = { name: "fa-solid-chevron-right", render: render$k };
const _hoisted_1$v = {
  viewBox: "0 0 320 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$s = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M34.52 239.03L228.87 44.69c9.37-9.37 24.57-9.37 33.94 0l22.67 22.67c9.36 9.36 9.37 24.52.04 33.9L131.49 256l154.02 154.75c9.34 9.38 9.32 24.54-.04 33.9l-22.67 22.67c-9.37 9.37-24.57 9.37-33.94 0L34.52 272.97c-9.37-9.37-9.37-24.57 0-33.94z"
}, null, -1);
const _hoisted_3$q = [
  _hoisted_2$s
];
function render$j(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$v, _hoisted_3$q);
}
var __unplugin_components_0$9 = { name: "fa-solid-chevron-left", render: render$j };
var galleryBackForwardBtns_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$d = {
  name: "backForwardBtns",
  props: ["viewportFloat"],
  methods: {
    navigate: function(direction) {
      if (this.$store.state.navHistory[direction].length > 0) {
        this.$store.commit("navHistory", { key: direction, value: this.$route.name });
        this.$router[direction]();
      }
    }
  }
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_fa_solid_chevron_left = __unplugin_components_0$9;
  const _component_fa_solid_chevron_right = __unplugin_components_0$a;
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["mobile-back-btns-wrapper", { "viewport-float": $props.viewportFloat }])
  }, [
    createBaseVNode("div", {
      class: normalizeClass(["mobile-back-btns", { disabled: _ctx.$store.state.navHistory.back.length < 1 }]),
      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $options.navigate("back"), ["prevent"]))
    }, [
      createVNode(_component_fa_solid_chevron_left)
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(["mobile-back-btns", { disabled: _ctx.$store.state.navHistory.forward.length < 1 }]),
      onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $options.navigate("forward"), ["prevent"]))
    }, [
      createVNode(_component_fa_solid_chevron_right)
    ], 2)
  ], 2);
}
var __unplugin_components_2$2 = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-7ea92576"]]);
const _hoisted_1$u = {
  viewBox: "0 0 448 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$r = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z"
}, null, -1);
const _hoisted_3$p = [
  _hoisted_2$r
];
function render$i(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$u, _hoisted_3$p);
}
var __unplugin_components_3$2 = { name: "fa-solid-bars", render: render$i };
const _hoisted_1$t = {
  viewBox: "0 0 256 256",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$q = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M240 128a16.1 16.1 0 0 1-7.7 13.7l-144 87.9a15.5 15.5 0 0 1-16.1.3A15.8 15.8 0 0 1 64 216V40a15.8 15.8 0 0 1 8.2-13.9a15.5 15.5 0 0 1 16.1.3l144 87.9A16.1 16.1 0 0 1 240 128Z"
}, null, -1);
const _hoisted_3$o = [
  _hoisted_2$q
];
function render$h(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$t, _hoisted_3$o);
}
var __unplugin_components_1$8 = { name: "ph-play-fill", render: render$h };
const _hoisted_1$s = {
  viewBox: "0 0 512 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$p = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128c0-70.7 57.2-128 128-128c70.7 0 128 57.2 128 128c0 70.7-57.2 128-128 128z"
}, null, -1);
const _hoisted_3$n = [
  _hoisted_2$p
];
function render$g(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$s, _hoisted_3$n);
}
var __unplugin_components_0$8 = { name: "fa-solid-search", render: render$g };
var galleryMobileMenuFloaters_vue_vue_type_style_index_0_scope_true_lang = "";
const _sfc_main$c = {
  name: "mobileMenuFloaters",
  props: ["mobileMenuOpen", "mobileThreshold"],
  data: function() {
    return {
      store: this.$store.state
    };
  },
  computed: {
    showMobilePlayerButton() {
      return !this.mobileMenuOpen && this.mobileThreshold && !this.store.showMobilePlayer && this.store.audioPlayer.audio;
    }
  }
};
const _hoisted_1$r = { class: "second-row" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_fa_solid_search = __unplugin_components_0$8;
  const _component_ph_play_fill = __unplugin_components_1$8;
  const _component_gallery_back_forward_btns = __unplugin_components_2$2;
  const _component_fa_solid_bars = __unplugin_components_3$2;
  return openBlock(), createElementBlock("div", {
    id: "mobile-menu-floaters",
    class: normalizeClass({ mobile: $props.mobileMenuOpen })
  }, [
    createBaseVNode("div", _hoisted_1$r, [
      _ctx.$store.state.searchMounted && !$props.mobileMenuOpen ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "search-btn",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("startSearching")),
        style: normalizeStyle({ top: $options.showMobilePlayerButton ? "-93px" : "-46px" })
      }, [
        createVNode(_component_fa_solid_search)
      ], 4)) : createCommentVNode("", true),
      $options.showMobilePlayerButton ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: "mobile-player-button",
        onClick: _cache[1] || (_cache[1] = ($event) => {
          _ctx.$store.commit("prop", { key: "showMobilePlayer", value: true });
        })
      }, [
        createVNode(_component_ph_play_fill)
      ])) : createCommentVNode("", true),
      _ctx.$store.state.displayMode && !$props.mobileMenuOpen ? (openBlock(), createBlock(_component_gallery_back_forward_btns, { key: 2 })) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: "burger-menu",
        onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("update:mobileMenuOpen", !$props.mobileMenuOpen))
      }, [
        createVNode(_component_fa_solid_bars, { class: "brgr-btn" })
      ])
    ])
  ], 2);
}
var __unplugin_components_1$7 = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
const _hoisted_1$q = {
  viewBox: "0 0 352 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$o = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "m242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28L75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256L9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"
}, null, -1);
const _hoisted_3$m = [
  _hoisted_2$o
];
function render$f(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$q, _hoisted_3$m);
}
var __unplugin_components_0$7 = { name: "fa-solid-times", render: render$f };
const _hoisted_1$p = {
  viewBox: "0 0 320 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$n = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M48 64C21.5 64 0 85.5 0 112v288c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48H48zm192 0c-26.5 0-48 21.5-48 48v288c0 26.5 21.5 48 48 48h32c26.5 0 48-21.5 48-48V112c0-26.5-21.5-48-48-48h-32z"
}, null, -1);
const _hoisted_3$l = [
  _hoisted_2$n
];
function render$e(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$p, _hoisted_3$l);
}
var __unplugin_components_1$6 = { name: "fa6-solid-pause", render: render$e };
const _hoisted_1$o = {
  viewBox: "0 0 384 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$m = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80v352c0 17.4 9.4 33.4 24.5 41.9S58.2 482 73 473l288-176c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"
}, null, -1);
const _hoisted_3$k = [
  _hoisted_2$m
];
function render$d(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$o, _hoisted_3$k);
}
var __unplugin_components_1$5 = { name: "fa6-solid-play", render: render$d };
var galleryAudioPlayerUiDesktop_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$b = {
  name: "audioPlayerUiDesktop",
  mixins: [makeCoverUrl],
  components: {
    VueSlider
  },
  data: function() {
    return {
      store: this.$store.state
    };
  },
  watch: {
    "store.audioPlayer.audio"(show) {
      this.$nextTick(() => {
        this.$store.commit("prop", { key: "desktopPlayerHeight", value: show ? this.$refs.player.offsetHeight / 2 + "px" : null });
      });
    }
  },
  computed: {
    progress: {
      get() {
        return this.store.audioPlayer.progress;
      },
      set(value) {
        this.$compEmitter.emit("audio-player-scrubbed", { target: { value } });
      }
    }
  }
};
const _hoisted_1$n = {
  id: "audio-player",
  ref: "player"
};
const _hoisted_2$l = { class: "inner-wrap" };
const _hoisted_3$j = { class: "player-innards" };
const _hoisted_4$5 = ["src", "content"];
const _hoisted_5$4 = {
  key: 0,
  class: "time-display left"
};
const _hoisted_6$3 = {
  key: 1,
  class: "time-display right"
};
const _hoisted_7$3 = { class: "player-buttons" };
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_vue_slider = resolveComponent("vue-slider");
  const _component_fa6_solid_play = __unplugin_components_1$5;
  const _component_fa6_solid_pause = __unplugin_components_1$6;
  const _component_fa_solid_times = __unplugin_components_0$7;
  const _component_ic_baseline_replay_30 = __unplugin_components_3$4;
  const _component_ic_baseline_forward_30 = __unplugin_components_4$4;
  const _directive_tippy = resolveDirective("tippy");
  return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$n, [
    createBaseVNode("div", _hoisted_2$l, [
      createBaseVNode("div", _hoisted_3$j, [
        withDirectives(createBaseVNode("img", {
          class: "book-cover",
          src: _ctx.makeCoverUrl(_ctx.$store.getters.audioPlayerBook.cover, 280),
          alt: "",
          content: (_ctx.$store.state.audioPlayer.sample ? "<strong>sample</strong> | " : "") + _ctx.$store.getters.audioPlayerTitle
        }, null, 8, _hoisted_4$5), [
          [_directive_tippy, { placement: "right", flipBehavior: ["right", "bottom"] }]
        ]),
        _ctx.store.audioPlayer.timeDisplay ? (openBlock(), createElementBlock("div", _hoisted_5$4, toDisplayString(_ctx.store.audioPlayer.timeDisplay), 1)) : createCommentVNode("", true),
        createVNode(_component_vue_slider, {
          style: { "width": "100%" },
          modelValue: $options.progress,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.progress = $event),
          tooltip: "none"
        }, null, 8, ["modelValue"]),
        _ctx.store.audioPlayer.timeDisplayLeft ? (openBlock(), createElementBlock("div", _hoisted_6$3, "-" + toDisplayString(_ctx.store.audioPlayer.timeDisplayLeft), 1)) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_7$3, [
          !_ctx.$store.state.audioPlayer.playing ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "play",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$compEmitter.emit("audio-player-play"))
          }, [
            createVNode(_component_fa6_solid_play)
          ])) : (openBlock(), createElementBlock("div", {
            key: 1,
            class: "pause",
            onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$compEmitter.emit("audio-player-pause"))
          }, [
            createVNode(_component_fa6_solid_pause)
          ])),
          createBaseVNode("div", {
            class: "stop",
            onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$compEmitter.emit("audio-player-stop"))
          }, [
            createVNode(_component_fa_solid_times)
          ]),
          createBaseVNode("div", {
            class: "back",
            onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$compEmitter.emit("audio-player-seek-back"))
          }, [
            createVNode(_component_ic_baseline_replay_30)
          ]),
          createBaseVNode("div", {
            class: "forward",
            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$compEmitter.emit("audio-player-seek-forward"))
          }, [
            createVNode(_component_ic_baseline_forward_30)
          ])
        ])
      ])
    ])
  ], 512)), [
    [vShow, _ctx.store.audioPlayer.audio]
  ]);
}
var __unplugin_components_4$3 = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-ba6d5ef2"]]);
const _hoisted_1$m = {
  viewBox: "0 0 640 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$k = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0l112.3-112.3zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5l112.2-112.3c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z"
}, null, -1);
const _hoisted_3$i = [
  _hoisted_2$k
];
function render$c(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$m, _hoisted_3$i);
}
var __unplugin_components_3$1 = { name: "fa6-solid-link", render: render$c };
const _hoisted_1$l = {
  viewBox: "0 0 1024 1024",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$j = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M640 384v256H384V384h256zm64 0h192v256H704V384zm-64 512H384V704h256v192zm64 0V704h192v192H704zm-64-768v192H384V128h256zm64 0h192v192H704V128zM320 384v256H128V384h192zm0 512H128V704h192v192zm0-768v192H128V128h192z"
}, null, -1);
const _hoisted_3$h = [
  _hoisted_2$j
];
function render$b(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$l, _hoisted_3$h);
}
var __unplugin_components_0$6 = { name: "ep-grid", render: render$b };
const _hoisted_1$k = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$i = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M4 3h16a2 2 0 0 1 2 2v15a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2m0 4v3h4V7H4m6 0v3h4V7h-4m10 3V7h-4v3h4M4 12v3h4v-3H4m0 8h4v-3H4v3m6-8v3h4v-3h-4m0 8h4v-3h-4v3m10 0v-3h-4v3h4m0-8h-4v3h4v-3Z"
}, null, -1);
const _hoisted_3$g = [
  _hoisted_2$i
];
function render$a(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$k, _hoisted_3$g);
}
var __unplugin_components_0$5 = { name: "mdi-table-large", render: render$a };
var galleryViewModeSwitcher_vue_vue_type_style_index_0_lang = "";
const _sfc_main$a = {
  name: "ViewModeSwitcher",
  props: ["justIcon"],
  data: function() {
    return {
      sticky: this.$store.state.sticky,
      viewModes: [
        "grid",
        "spreadsheet"
      ]
    };
  },
  methods: {
    changeViewMode: function() {
      let viewModeIndex = _.findIndex(this.viewModes, (v) => {
        return v === this.sticky.viewMode;
      });
      if (viewModeIndex + 1 > this.viewModes.length - 1)
        viewModeIndex = 0;
      else
        viewModeIndex = viewModeIndex + 1;
      const newViewMode = this.viewModes[viewModeIndex];
      this.$store.commit("stickyProp", { key: "viewMode", value: newViewMode });
      this.$updateQueries({ y: null, view: newViewMode });
    }
  }
};
const _hoisted_1$j = ["content"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_mdi_table_large = __unplugin_components_0$5;
  const _component_ep_grid = __unplugin_components_0$6;
  const _directive_tippy = resolveDirective("tippy");
  return withDirectives((openBlock(), createElementBlock("div", {
    class: normalizeClass(["view-mode-switcher icon", { "no-style": $props.justIcon }]),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.changeViewMode && $options.changeViewMode(...args)),
    content: "Change to <strong>" + (_ctx.sticky.viewMode === "grid" ? "spreadsheet" : "grid") + "</strong> view"
  }, [
    _ctx.sticky.viewMode === "grid" ? (openBlock(), createBlock(_component_mdi_table_large, {
      key: 0,
      class: "icon"
    })) : _ctx.sticky.viewMode === "spreadsheet" ? (openBlock(), createBlock(_component_ep_grid, {
      key: 1,
      class: "icon"
    })) : createCommentVNode("", true)
  ], 10, _hoisted_1$j)), [
    [_directive_tippy, { allowHTML: true }]
  ]);
}
var __unplugin_components_4$2 = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
var gallerySearchButton_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$9 = {
  props: ["float"],
  methods: {
    startSearching() {
      this.$compEmitter.emit("ios-auto-zoom-disable");
      this.$compEmitter.emit("search-focus");
    }
  }
};
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_fa_solid_search = __unplugin_components_0$8;
  const _directive_tippy = resolveDirective("tippy");
  return _ctx.$store.state.searchMounted || true ? withDirectives((openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass(["search-btn icon", { float: $props.float }]),
    onClick: _cache[0] || (_cache[0] = (...args) => $options.startSearching && $options.startSearching(...args)),
    content: '\n    Click to scroll up and search. <br>\n    Read about advanced search operators \n    <a target="_blank" rel="noopener noreferrer" href="https://joonaspaakko.gitbook.io/audible-library-extractor/gallery/advanced-search">\n      here\n    </a>.'
  }, [
    createVNode(_component_fa_solid_search)
  ], 2)), [
    [_directive_tippy, { interactive: true, allowHTML: true }]
  ]) : createCommentVNode("", true);
}
var __unplugin_components_1$4 = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-3a7ede6c"]]);
const _hoisted_1$i = {
  viewBox: "0 0 384 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$h = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M223.5 32C100 32 0 132.3 0 256s100 224 223.5 224c60.6 0 115.5-24.2 155.8-63.4c5-4.9 6.3-12.5 3.1-18.7s-10.1-9.7-17-8.5c-9.8 1.7-19.8 2.6-30.1 2.6c-96.9 0-175.5-78.8-175.5-176c0-65.8 36-123.1 89.3-153.3c6.1-3.5 9.2-10.5 7.7-17.3s-7.3-11.9-14.3-12.5c-6.3-.5-12.6-.8-19-.8z"
}, null, -1);
const _hoisted_3$f = [
  _hoisted_2$h
];
function render$9(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$i, _hoisted_3$f);
}
var __unplugin_components_1$3 = { name: "fa6-solid-moon", render: render$9 };
const _hoisted_1$h = {
  viewBox: "0 0 512 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$g = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M361.5 1.2c5 2.1 8.6 6.6 9.6 11.9L391 121l107.9 19.8c5.3 1 9.8 4.6 11.9 9.6s1.5 10.7-1.6 15.2L446.9 256l62.3 90.3c3.1 4.5 3.7 10.2 1.6 15.2s-6.6 8.6-11.9 9.6L391 391l-19.9 107.9c-1 5.3-4.6 9.8-9.6 11.9s-10.7 1.5-15.2-1.6L256 446.9l-90.3 62.3c-4.5 3.1-10.2 3.7-15.2 1.6s-8.6-6.6-9.6-11.9L121 391L13.1 371.1c-5.3-1-9.8-4.6-11.9-9.6s-1.5-10.7 1.6-15.2L65.1 256L2.8 165.7c-3.1-4.5-3.7-10.2-1.6-15.2s6.6-8.6 11.9-9.6L121 121l19.9-107.9c1-5.3 4.6-9.8 9.6-11.9s10.7-1.5 15.2 1.6L256 65.1l90.3-62.3c4.5-3.1 10.2-3.7 15.2-1.6zM352 256c0 53-43 96-96 96s-96-43-96-96s43-96 96-96s96 43 96 96zm32 0c0-70.7-57.3-128-128-128s-128 57.3-128 128s57.3 128 128 128s128-57.3 128-128z"
}, null, -1);
const _hoisted_3$e = [
  _hoisted_2$g
];
function render$8(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$h, _hoisted_3$e);
}
var __unplugin_components_0$4 = { name: "fa6-solid-sun", render: render$8 };
var galleryLightSwitch_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$8 = {
  name: "lightSwitch",
  data: function() {
    return {
      tippyContent: ""
    };
  },
  created: function() {
    this.lightSwitchToggle(true);
  },
  methods: {
    lightSwitchToggle: function(onLoad) {
      if (!onLoad) {
        this.$store.commit("stickyProp", { key: "lightSwitch", value: this.$store.state.sticky.lightSwitch ? 0 : 1 });
        if (!this.$store.state.sticky.lightSwitchSetByUser)
          this.$store.commit("stickyProp", { key: "lightSwitchSetByUser", value: true });
      } else {
        this.autoLightsOff();
      }
      const html = document.querySelector("html");
      html.classList.remove("theme-light");
      html.classList.remove("theme-dark");
      html.classList.add(
        !this.$store.state.sticky.lightSwitch ? "theme-dark" : "theme-light"
      );
    },
    autoLightsOff: function() {
      if (window.matchMedia("(prefers-color-scheme)").media !== "not all" && this.$store.state.sticky.lightSwitch && !this.$store.state.sticky.lightSwitchSetByUser) {
        this.$store.commit("stickyProp", { key: "lightSwitch", value: 0 });
      }
    }
  }
};
const _hoisted_1$g = { class: "light-switch text-button" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_fa6_solid_sun = __unplugin_components_0$4;
  const _component_fa6_solid_moon = __unplugin_components_1$3;
  return openBlock(), createElementBlock("div", _hoisted_1$g, [
    createBaseVNode("div", {
      class: "icon",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.lightSwitchToggle(false))
    }, [
      _ctx.$store.state.sticky.lightSwitch ? (openBlock(), createBlock(_component_fa6_solid_sun, { key: 0 })) : (openBlock(), createBlock(_component_fa6_solid_moon, { key: 1 }))
    ])
  ]);
}
var __unplugin_components_0$3 = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-f55d5b5a"]]);
var galleryNavigationLooper_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$7 = {
  name: "menuLooper",
  props: ["routes", "childRoutes", "mobileMenuOpen", "inRoot", "desktopMenu"],
  data: function() {
    return {
      menuOpen: true,
      copiedToClipboard: false
    };
  },
  methods: {
    getHrefAttr(route) {
      return route.tag === "a" ? "href" : "to";
    },
    itemActive(route) {
      const currentRoute = this.$route.name;
      const linkActive = currentRoute === route.name || _.find(route.children, { name: currentRoute });
      return linkActive ? "router-link-active" : null;
    },
    subItemActive(route) {
      const currentRoute = this.$route.name;
      const linkActive = _.find(route.childItems, function(route2) {
        return currentRoute === route2.name || _.find(route2.children, { name: currentRoute });
      });
      return linkActive ? "router-link-active" : null;
    },
    getRoutePath(route) {
      const path = _.get(route, "path");
      return !!path ? {
        name: _.get(route, "name") || _.get(route, "children[0].name"),
        query: { refresh: true }
      } : _.get(route, "href");
    },
    getRouteName(route) {
      if (route.altName) {
        return route.altName(route);
      } else {
        const name = _.get(route, "children[0].meta.title") || _.get(route, "children[0].name") || route.name;
        const extensionTools = _.get(route, "meta.nestedGroup") === "extension-tools";
        return extensionTools ? name : _.startCase(name);
      }
    },
    closeMenu() {
      this.menuOpen = false;
      this.$nextTick(function() {
        this.menuOpen = true;
      });
    },
    additionalClick(route) {
      if (this.mobileMenuOpen) {
        this.$emit("update:mobileMenuOpen", !this.mobileMenuOpen);
      } else {
        this.$emit("closeMenu");
      }
    },
    copyToClipboard() {
      navigator.clipboard.writeText(window.location.href);
      const iconEl = _.get(this.$refs, "copyToClipboard.$el") || _.get(this.$refs, "copyToClipboard.$el");
      iconEl._tippy.show();
      setTimeout(() => {
        iconEl._tippy.hide();
      }, 2e3);
    }
  }
};
const _hoisted_1$f = { key: 0 };
const _hoisted_2$f = {
  key: 1,
  class: "mobile-menu-top-spacer"
};
const _hoisted_3$d = ["onClick"];
const _hoisted_4$4 = {
  key: 0,
  class: "menu-item-icon"
};
const _hoisted_5$3 = ["innerHTML"];
const _hoisted_6$2 = {
  key: 0,
  class: "sub-menu"
};
const _hoisted_7$2 = {
  key: 2,
  class: "menu-icon-toolbar"
};
const _hoisted_8$2 = { key: 0 };
const _hoisted_9$2 = { key: 1 };
const _hoisted_10$2 = { key: 2 };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_menuLooper = resolveComponent("menuLooper");
  const _component_gallery_light_switch = __unplugin_components_0$3;
  const _component_gallery_search_button = __unplugin_components_1$4;
  const _component_gallery_view_mode_switcher = __unplugin_components_4$2;
  const _component_fa6_solid_link = __unplugin_components_3$1;
  const _component_gallery_audio_player_ui_desktop = __unplugin_components_4$3;
  const _directive_tippy = resolveDirective("tippy");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["menu-items", { "has-sub-menu": $props.childRoutes, mobileMenu: $props.mobileMenuOpen }])
  }, [
    _ctx.menuOpen ? (openBlock(), createElementBlock("div", _hoisted_1$f, [
      $props.mobileMenuOpen ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: "mobile-menu-top-filler",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:mobileMenuOpen", !$props.mobileMenuOpen))
      })) : createCommentVNode("", true),
      $props.mobileMenuOpen ? (openBlock(), createElementBlock("div", _hoisted_2$f)) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.routes, (route) => {
        return withDirectives((openBlock(), createBlock(resolveDynamicComponent(route.tag || "router-link"), normalizeProps({
          tabindex: "0",
          key: route.path,
          [$options.getHrefAttr(route) || ""]: $options.getRoutePath(route),
          target: route.href ? "_blank" : null,
          class: ["menu-item", [
            route.meta.groupName,
            $options.itemActive(route),
            $options.subItemActive(route),
            route.disabled || (route.condition ? !route.condition() : null) ? "disabled" : "",
            route.highlight ? "highlight" : "null"
          ]],
          content: typeof route.tippy === "function" ? route.tippy() : route.tippy,
          onClick: ($event) => route.click ? route.click(route) : null
        }), {
          default: withCtx(() => [
            createBaseVNode("div", {
              class: "menu-item-inner",
              onClick: ($event) => $options.additionalClick(route)
            }, [
              route.meta.icon ? (openBlock(), createElementBlock("span", _hoisted_4$4, [
                createBaseVNode("i", {
                  class: normalizeClass(route.meta.icon)
                }, null, 2)
              ])) : createCommentVNode("", true),
              createBaseVNode("span", {
                class: "menu-item-text",
                innerHTML: $options.getRouteName(route)
              }, null, 8, _hoisted_5$3)
            ], 8, _hoisted_3$d),
            route.childItems ? (openBlock(), createElementBlock("div", _hoisted_6$2, [
              createVNode(_component_menuLooper, {
                routes: route.childItems,
                childRoutes: route.childItems,
                onCloseMenu: $options.closeMenu
              }, null, 8, ["routes", "childRoutes", "onCloseMenu"])
            ])) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1040, ["target", "class", "content", "onClick"])), [
          [_directive_tippy, { placement: "left", flipBehavior: ["left", "top", "bottom"], maxWidth: 400 }]
        ]);
      }), 128)),
      $props.inRoot ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
        createBaseVNode("div", null, [
          createVNode(_component_gallery_light_switch)
        ]),
        !$props.mobileMenuOpen ? (openBlock(), createElementBlock("div", _hoisted_8$2, [
          createVNode(_component_gallery_search_button)
        ])) : createCommentVNode("", true),
        $props.mobileMenuOpen ? (openBlock(), createElementBlock("div", _hoisted_9$2, [
          _ctx.$store.state.searchMounted ? (openBlock(), createBlock(_component_gallery_view_mode_switcher, {
            key: 0,
            justIcon: true
          })) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        $props.mobileMenuOpen ? (openBlock(), createElementBlock("div", _hoisted_10$2, [
          withDirectives(createVNode(_component_fa6_solid_link, {
            class: "icon",
            onClick: _cache[1] || (_cache[1] = ($event) => $options.copyToClipboard()),
            content: "Page URL copied to clipboard!",
            ref: "copyToClipboard"
          }, null, 512), [
            [_directive_tippy, { trigger: "manual" }]
          ])
        ])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    $props.inRoot && $props.desktopMenu ? (openBlock(), createBlock(_component_gallery_audio_player_ui_desktop, { key: 1 })) : createCommentVNode("", true)
  ], 2);
}
var __unplugin_components_0$2 = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-6c173dab"]]);
var galleryModal_vue_vue_type_style_index_0_lang = "";
const _sfc_main$6 = {
  name: "modal",
  props: ["toggled"],
  data: function() {
    return {
      modalOpen: true
    };
  },
  created: function() {
  },
  mounted() {
    this.$store.commit("prop", { key: "preventScrolling", value: true });
  },
  beforeUnmount() {
    this.$store.commit("prop", { key: "preventScrolling", value: false });
  },
  methods: {
    close: function() {
      this.$emit("closeModal");
    },
    closeOverlay: function(e) {
      let vue = this;
      if (e.target === this.$refs.modalGrandpa || e.target === this.$refs.modalPapa) {
        vue.close();
      }
    }
  }
};
const _hoisted_1$e = {
  class: "outer-wrap",
  ref: "modalPapa"
};
const _hoisted_2$e = { class: "inner-wrap" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_fa_solid_times = __unplugin_components_0$7;
  const _directive_shortkey = resolveDirective("shortkey");
  return openBlock(), createElementBlock("div", {
    id: "modal-wrapper",
    ref: "modalGrandpa",
    onClick: _cache[2] || (_cache[2] = (...args) => $options.closeOverlay && $options.closeOverlay(...args))
  }, [
    createBaseVNode("div", _hoisted_1$e, [
      createBaseVNode("div", _hoisted_2$e, [
        renderSlot(_ctx.$slots, "default"),
        withDirectives((openBlock(), createElementBlock("div", {
          class: "close-btn",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.close && $options.close(...args)),
          onShortkey: _cache[1] || (_cache[1] = (...args) => $options.close && $options.close(...args))
        }, [
          createVNode(_component_fa_solid_times)
        ], 32)), [
          [
            _directive_shortkey,
            ["esc"],
            void 0,
            { once: true }
          ]
        ])
      ])
    ], 512)
  ], 512);
}
var __unplugin_components_1$2 = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const _hoisted_1$d = {
  viewBox: "0 0 16 16",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$d = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  "fill-rule": "evenodd",
  d: "M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"
}, null, -1);
const _hoisted_3$c = [
  _hoisted_2$d
];
function render$7(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$d, _hoisted_3$c);
}
var __unplugin_components_4$1 = { name: "octicon-mark-github16", render: render$7 };
const _hoisted_1$c = {
  viewBox: "0 0 512 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M288 32c0-17.7-14.3-32-32-32s-32 14.3-32 32v242.7l-73.4-73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0l128-128c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L288 274.7V32zM64 352c-35.3 0-64 28.7-64 64v32c0 35.3 28.7 64 64 64h384c35.3 0 64-28.7 64-64v-32c0-35.3-28.7-64-64-64H346.5l-45.3 45.3c-25 25-65.5 25-90.5 0L165.5 352H64zm368 104c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"
}, null, -1);
const _hoisted_3$b = [
  _hoisted_2$c
];
function render$6(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$c, _hoisted_3$b);
}
var __unplugin_components_3 = { name: "fa6-solid-download", render: render$6 };
const _hoisted_1$b = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$b = /* @__PURE__ */ createStaticVNode('<g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="2 4" stroke-dashoffset="6" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21"><animate attributeName="stroke-dashoffset" dur="0.6s" repeatCount="indefinite" values="6;0"></animate></path><path stroke-dasharray="30" stroke-dashoffset="30" d="M12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.1s" dur="0.3s" values="30;0"></animate></path><path stroke-dasharray="10" stroke-dashoffset="10" d="M12 8v7.5"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.5s" dur="0.2s" values="10;0"></animate></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 15.5l3.5 -3.5M12 15.5l-3.5 -3.5"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.7s" dur="0.2s" values="6;0"></animate></path></g>', 1);
const _hoisted_3$a = [
  _hoisted_2$b
];
function render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$b, _hoisted_3$a);
}
var __unplugin_components_2$1 = { name: "line-md-downloading-loop", render: render$5 };
const _hoisted_1$a = {
  viewBox: "0 0 512 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$a = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "m173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69L432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"
}, null, -1);
const _hoisted_3$9 = [
  _hoisted_2$a
];
function render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_3$9);
}
var __unplugin_components_5 = { name: "fa-solid-check", render: render$4 };
var saveGallery_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$5 = {
  name: "saveGallery",
  components: {
    modal: __unplugin_components_1$2
  },
  data: function() {
    return {
      files: [],
      dataSources: [
        { checked: true, disabled: false, key: "Library" },
        { checked: true, disabled: false, key: "Categories", parent: ["Library", "Wishlist"], subPage: true },
        { checked: true, disabled: false, key: "Authors", parent: ["Library", "Wishlist"], subPage: true },
        { checked: true, disabled: false, key: "Publishers", parent: ["Library", "Wishlist"], subPage: true },
        { checked: true, disabled: false, key: "Collections", parent: "Library" },
        { checked: true, disabled: false, key: "Series", parent: ["Library", "Wishlist"], subPage: true },
        { checked: true, disabled: false, key: "Narrators", parent: ["Library", "Wishlist"], subPage: true },
        { checked: true, disabled: false, key: "Wishlist" },
        { checked: true, disabled: true, key: "Export archived books", extra: true, tippy: 'If unchecked, the "archive" collection and all archived books are excluded from the export and "My books in the series" will list archived books as not owned. This option is disabled if the archive is empty.' }
      ],
      zip: null,
      cacheBuster: null,
      bundling: false,
      saveBtnEnabled: true,
      progressWidth: null,
      iconSize: 20
    };
  },
  created: function() {
    this.files = window.chunksFilePaths;
    let vue = this;
    if (this.$store.state.sticky.exportSettingsGallery) {
      _.each(this.$store.state.sticky.exportSettingsGallery, function(stickySource) {
        var source = _.find(vue.dataSources, { key: stickySource.key });
        source.checked = stickySource.checked;
        source.disabled = stickySource.disabled;
      });
    }
    let librarySource = _.find(this.dataSources, { key: "Library" });
    librarySource.disabled = !this.$store.state.library.books;
    let wishlistSource = _.find(this.dataSources, { key: "Wishlist" });
    wishlistSource.disabled = !this.$store.state.library.wishlist;
    let collections = this.$store.state.library.collections;
    let archive = collections ? _.find(collections, { id: "__ARCHIVE" }) : null;
    if (archive && archive.books.length > 0) {
      let archivedSource = _.find(this.dataSources, { key: "Export archived books" });
      if (archivedSource)
        archivedSource.disabled = false;
    }
  },
  mounted: function() {
    let vue = this;
    this.iconSize = this.$refs.textWrapper.offsetHeight;
    if (vue.$store.getters.saveStandaloneAfter) {
      this.$nextTick(function() {
        try {
          let newConfig = JSON.parse(JSON.stringify(vue.$store.state.extractSettings));
          let saveStandaloneAfter = _.find(newConfig.extraSettings, { name: "saveStandaloneAfter" });
          saveStandaloneAfter.deactivated = true;
          this.$store.commit("prop", { key: "extractSettings", value: newConfig });
          chrome.storage.local.set({ config: newConfig }).then(function() {
            vue.saveButtonClicked();
          });
        } catch (e) {
        }
      });
    }
  },
  beforeUnmount: function() {
    this.zip = null;
    this.cacheBuster = null;
  },
  computed: {
    chunkSource: function() {
      return _.chunk(this.dataSources, 4);
    }
  },
  methods: {
    cancelZipping: function() {
      window.location.reload();
    },
    divideLargerDatapoints: function(zip, books) {
      let vue = this;
      _.each(books, function(book) {
        let fileData = "";
        if (book.peopleAlsoBought && book.asin) {
          fileData += "window.peopleAlsoBoughtJSON = " + JSON.stringify(book.peopleAlsoBought) + "; \n";
          delete book.peopleAlsoBought;
        }
        if (book.summary && book.asin) {
          fileData += "window.bookSummaryJSON = " + JSON.stringify(book.summary) + "; \n";
          delete book.summary;
        }
        if (fileData !== "") {
          zip.file("data/split-book-data/" + book.asin + "." + vue.cacheBuster + ".js", fileData);
        }
      });
    },
    saveButtonClicked: async function() {
      const vue = this;
      if (this.bundling || this.$store.state.devMode)
        return;
      try {
        vue.bundling = true;
        vue.$store.commit("prop", { key: "bundlingGallery", value: true });
        vue.cacheBuster = this.runCachebuster();
        vue.zip = new JSZip();
        const zip = vue.zip;
        zip.file(".nojekyll", "");
        let libraryData = this.excludeData(JSON.parse(JSON.stringify(this.$store.state.library)));
        libraryData.extras.cacheID = vue.cacheBuster;
        let tempData = {
          books: !!libraryData.books,
          series: !!libraryData.series,
          collections: !!libraryData.collections,
          wishlist: !!libraryData.wishlist,
          extras: libraryData.extras
        };
        let loadServiceWorker = `
          if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('service-worker.${vue.cacheBuster}.js')
            .then(function(registration) {
              console.log('Registration successful, scope is:', registration.scope);
            })
            .catch(function(error) {
              console.log('Service worker registration failed, error:', error);
            });
          }
        `;
        const useServiceWorker = false;
        loadServiceWorker = useServiceWorker ? "<script>" + loadServiceWorker + "<\/script>" : "";
        const getFile = function(name, ext) {
          let regex = "^assets\\/" + name + "\\..+\\." + (ext || "js") + "$";
          regex = new RegExp(regex);
          return _.find(vue.files, (file) => file.match(regex));
        };
        const indexHTML = '<!DOCTYPE html><html lang="en" class="theme-dark standalone-gallery" style="background: #171717; min-height: 100%;"><head><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2048-2732.jpg" media="(prefers-color-scheme: dark) and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2732-2048.jpg" media="(prefers-color-scheme: dark) and (device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1668-2388.jpg" media="(prefers-color-scheme: dark) and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2388-1668.jpg" media="(prefers-color-scheme: dark) and (device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1536-2048.jpg" media="(prefers-color-scheme: dark) and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2048-1536.jpg" media="(prefers-color-scheme: dark) and (device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1668-2224.jpg" media="(prefers-color-scheme: dark) and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2224-1668.jpg" media="(prefers-color-scheme: dark) and (device-width: 834px) and (device-height: 1112px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1620-2160.jpg" media="(prefers-color-scheme: dark) and (device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2160-1620.jpg" media="(prefers-color-scheme: dark) and (device-width: 810px) and (device-height: 1080px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1290-2796.jpg" media="(prefers-color-scheme: dark) and (device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2796-1290.jpg" media="(prefers-color-scheme: dark) and (device-width: 430px) and (device-height: 932px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1179-2556.jpg" media="(prefers-color-scheme: dark) and (device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2556-1179.jpg" media="(prefers-color-scheme: dark) and (device-width: 393px) and (device-height: 852px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1284-2778.jpg" media="(prefers-color-scheme: dark) and (device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2778-1284.jpg" media="(prefers-color-scheme: dark) and (device-width: 428px) and (device-height: 926px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1170-2532.jpg" media="(prefers-color-scheme: dark) and (device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2532-1170.jpg" media="(prefers-color-scheme: dark) and (device-width: 390px) and (device-height: 844px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1125-2436.jpg" media="(prefers-color-scheme: dark) and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2436-1125.jpg" media="(prefers-color-scheme: dark) and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1242-2688.jpg" media="(prefers-color-scheme: dark) and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2688-1242.jpg" media="(prefers-color-scheme: dark) and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-828-1792.jpg" media="(prefers-color-scheme: dark) and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1792-828.jpg" media="(prefers-color-scheme: dark) and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1242-2208.jpg" media="(prefers-color-scheme: dark) and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-2208-1242.jpg" media="(prefers-color-scheme: dark) and (device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-750-1334.jpg" media="(prefers-color-scheme: dark) and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1334-750.jpg" media="(prefers-color-scheme: dark) and (device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-640-1136.jpg" media="(prefers-color-scheme: dark) and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)"><link rel="apple-touch-startup-image" href="favicons/apple-splash-dark-1136-640.jpg" media="(prefers-color-scheme: dark) and (device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: landscape)"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta http-equiv="Cache-control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="mobile-web-app-capable" content="yes"><link rel="apple-touch-icon" sizes="180x180" href="favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="favicons/favicon-16x16.png"><link rel="manifest" href="app.webmanifest"><link rel="mask-icon" href="favicons/safari-pinned-tab.svg" color="#f29a33"><link rel="shortcut icon" href="favicons/favicon.ico"><meta name="msapplication-TileColor" content="#222222"><meta name="msapplication-config" content="favicons/browserconfig.xml"><meta name="theme-color" content="#f29a33"><title>My Audible Library</title>' + loadServiceWorker + '<link id="ale-css" rel="stylesheet" href="' + getFile("gallery", "css") + '"></head><body><div id="audible-library-extractor" data-version="' + this.$store.state.version + '" data-cache-id="' + vue.cacheBuster + '"></div><script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"><\/script><script id="ale-js" src="' + getFile("gallery", "js") + '" type="module"><\/script><noscript>This library requires javascript to work!</noscript></body></html>';
        zip.file("index.html", indexHTML);
        zip.file("ALE-Documentation.url", `[InternetShortcut]
URL=https://joonaspaakko.gitbook.io/audible-library-extractor/`);
        if (libraryData.wishlist && libraryData.books) {
          this.divideLargerDatapoints(zip, _.unionBy(libraryData.books, libraryData.wishlist, "asin"));
        } else {
          if (libraryData.wishlist)
            this.divideLargerDatapoints(zip, libraryData.wishlist);
          if (libraryData.books)
            this.divideLargerDatapoints(zip, libraryData.books);
        }
        zip.file("data/temp-data." + vue.cacheBuster + ".js", "window.tempDataJSON = " + JSON.stringify(tempData) + ";");
        if (libraryData.books) {
          zip.file("data/library." + vue.cacheBuster + ".js", "window.libraryJSON = " + JSON.stringify(libraryData.books) + ";");
        }
        if (libraryData.collections) {
          zip.file("data/collections." + vue.cacheBuster + ".js", "window.collectionsJSON = " + JSON.stringify(libraryData.collections) + ";");
        }
        if (libraryData.series) {
          zip.file("data/series." + vue.cacheBuster + ".js", "window.seriesJSON = " + JSON.stringify(libraryData.series) + ";");
        }
        if (libraryData.wishlist) {
          zip.file("data/wishlist." + vue.cacheBuster + ".js", "window.wishlistJSON = " + JSON.stringify(libraryData.wishlist) + ";");
        }
        console.log(_.cloneDeep(vue.files));
        _.remove(vue.files, function(file) {
          const filename = file.replace(/^assets\//, "");
          if (filename === "gallery.html")
            return true;
          const matches = [
            !!filename.match(/^gallery/),
            !!filename.match(/^content-script-helpers/),
            !!filename.match(/^howler/),
            !!filename.match(/^lodash/),
            !!filename.match(/^tippy/),
            !!filename.match(/^jquery/),
            !!filename.match(/^fuse.esm/),
            !!filename.match(/^index\..*\.js$/),
            !!filename.match(/^Roboto/i),
            !!filename.match(/^Inconsolata/i),
            !!filename.match(/^vue\.runtime\.esm-bundler/i),
            !!filename.match(/^fa-.+(woff2?|ttf)/)
          ];
          return !_.includes(matches, true);
        });
        vue.files = vue.files.concat([
          "favicons/android-chrome-192x192.png",
          "favicons/android-chrome-512x512.png",
          "favicons/apple-touch-icon.png",
          "favicons/browserconfig.xml",
          "favicons/favicon-16x16.png",
          "favicons/favicon-32x32.png",
          "favicons/favicon.ico",
          "favicons/mstile-150x150.png",
          "favicons/safari-pinned-tab.svg",
          "favicons/apple-splash-dark-2436-1125.jpg",
          "favicons/apple-splash-dark-2532-1170.jpg",
          "favicons/apple-splash-dark-2048-1536.jpg",
          "favicons/apple-splash-dark-1620-2160.jpg",
          "favicons/apple-splash-dark-2796-1290.jpg",
          "favicons/apple-splash-dark-750-1334.jpg",
          "favicons/apple-splash-dark-1179-2556.jpg",
          "favicons/apple-splash-dark-1792-828.jpg",
          "favicons/apple-splash-dark-1284-2778.jpg",
          "favicons/apple-splash-dark-1668-2224.jpg",
          "favicons/apple-splash-dark-1242-2688.jpg",
          "favicons/apple-splash-dark-2224-1668.jpg",
          "favicons/apple-splash-dark-2732-2048.jpg",
          "favicons/apple-splash-dark-1334-750.jpg",
          "favicons/apple-splash-dark-1136-640.jpg",
          "favicons/apple-splash-dark-2778-1284.jpg",
          "favicons/apple-splash-dark-1290-2796.jpg",
          "favicons/apple-splash-dark-2208-1242.jpg",
          "favicons/apple-splash-dark-2388-1668.jpg",
          "favicons/apple-splash-dark-2048-2732.jpg",
          "favicons/apple-splash-dark-2160-1620.jpg",
          "favicons/apple-splash-dark-1536-2048.jpg",
          "favicons/apple-splash-dark-1668-2388.jpg",
          "favicons/apple-splash-dark-1170-2532.jpg",
          "favicons/apple-splash-dark-1242-2208.jpg",
          "favicons/apple-splash-dark-1125-2436.jpg",
          "favicons/apple-splash-dark-640-1136.jpg",
          "favicons/apple-splash-dark-2556-1179.jpg",
          "favicons/apple-splash-dark-828-1792.jpg",
          "favicons/apple-splash-dark-2688-1242.jpg",
          "app.webmanifest"
        ]);
        console.log(vue.files);
        for (let url of vue.files) {
          const data = await JSZipUtils.getBinaryContent(url);
          zip.file(url, data, { binary: true });
        }
        const content = await zip.generateAsync({ type: "blob", streamFiles: true }, function updateCallback(metadata) {
          vue.progressWidth = metadata.percent + "%";
        });
        saveAs(content, "ALE-gallery.zip");
      } finally {
        setTimeout(function() {
          vue.bundling = false;
          vue.$store.commit("prop", { key: "bundlingGallery", value: false });
          vue.progressWidth = 0;
        }, 1e3);
      }
    },
    sourceChecked: function(e, item) {
      let vue = this;
      let children = _.filter(this.dataSources, function(source) {
        return _.isArray(source.parent) ? _.includes(source.parent, item.key) : source.parent === item.key;
      });
      _.each(children, function(child) {
        if (_.isArray(child.parent)) {
          let parents = _.map(child.parent, function(parent) {
            return _.find(vue.dataSources, { key: parent });
          });
          let parentsEnabled = _.filter(parents, function(parent) {
            return parent.checked && !parent.disabled;
          }).length > 0;
          child.disabled = !e.target.checked && !parentsEnabled;
        } else {
          child.disabled = !e.target.checked;
        }
      });
      let checkedSources = _.filter(this.dataSources, { checked: true, disabled: false });
      this.saveBtnEnabled = !!checkedSources.length;
      this.$store.commit("stickyProp", { key: "exportSettingsGallery", value: this.dataSources });
    },
    excludeData: function(data) {
      _.each(this.dataSources, function(item) {
        var lowercaseKey = item.key.toLowerCase();
        var itemDisabled = !item.checked || item.disabled;
        switch (item.key) {
          case "Library":
            if (itemDisabled) {
              delete data.books;
              delete data.series;
              delete data.collections;
            }
            break;
          case "Series":
            if (itemDisabled) {
              delete data.series;
            }
            break;
          case "Collections":
            if (itemDisabled)
              delete data.collections;
            break;
          case "Wishlist":
            if (itemDisabled) {
              delete data.wishlist;
            }
            break;
          case "Export archived books":
            if (itemDisabled) {
              let collections = data.collections;
              let archive = collections ? _.find(collections, { id: "__ARCHIVE" }) : null;
              if (archive && archive.books.length > 0 && data.books) {
                _.remove(data.books, "archived");
                if (data.series) {
                  _.each(data.series, function(series) {
                    if (series.books.length > 0) {
                      _.remove(series.books, function(book) {
                        return _.includes(archive.books, book);
                      });
                    }
                    if (series.allBooks.length > 0) {
                      _.each(series.allBooks, function(book) {
                        const inArchive = _.includes(archive.books, book.asin);
                        if (inArchive)
                          book.notInLibrary = true;
                      });
                    }
                  });
                  _.remove(data.series, function(series) {
                    return series.books.length === 0;
                  });
                }
                _.each(collections, function(collection) {
                  _.remove(collection.books, function(book) {
                    return _.includes(archive.books, book);
                  });
                });
              }
              if (archive)
                _.remove(collections, function(collection) {
                  return collection.id === "__ARCHIVE" || !collection.books || collection.books.length === 0;
                });
            }
            break;
        }
        if (item.subPage) {
          data.extras.subPageStates = data.extras.subPageStates || [];
          data.extras.subPageStates.push({
            key: lowercaseKey,
            enabled: !itemDisabled
          });
        }
      });
      return data;
    },
    serviceWorker: function() {
      return `
      importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.1.5/workbox-sw.js');

      workbox.setConfig({
        debug: false,
      });

      const {registerRoute} = workbox.routing;
      const {
        NetworkFirst,
        StaleWhileRevalidate,
        CacheFirst
      } = workbox.strategies;
      const CacheableResponsePlugin = workbox.cacheableResponse.CacheableResponsePlugin;
      const ExpirationPlugin = workbox.expiration.ExpirationPlugin;

      // Cache page navigations (html) with a Network First strategy
      registerRoute(
        // Check to see if the request is a navigation to a new page
        ({ request }) => request.mode === 'navigate',
        // Use a Network First caching strategy
        new NetworkFirst({
          // Put all cached files in a cache named 'pages'
          cacheName: 'pages',
          plugins: [
            // Ensure that only requests that result in a 200 status are cached
            new CacheableResponsePlugin({
              statuses: [200],
            }),
          ],
        }),
      );

      // Cache CSS, JS, and Web Worker requests with a Stale While Revalidate strategy
      registerRoute(
        // Check to see if the request's destination is style for stylesheets, script for JavaScript, or worker for web worker
        ({ request }) =>
          request.destination === 'style' ||
          request.destination === 'script' ||
          request.destination === 'worker',
        // Use a Stale While Revalidate caching strategy
        new StaleWhileRevalidate({
          // Put all cached files in a cache named 'assets'
          cacheName: 'assets',
          plugins: [
            // Ensure that only requests that result in a 200 status are cached
            new CacheableResponsePlugin({
              statuses: [200],
            }),
          ],
        }),
      );

      // Cache images with a Cache First strategy
      registerRoute(
        // Check to see if the request's destination is style for an image
        ({ url, request }) =>
          (request.destination === 'image' && url.origin !== 'https://m.media-amazon.com') ||
          (request.destination === 'image' && url.origin === 'https://m.media-amazon.com' && !url.href.match(/_SL200_/) && !url.href.match(/_SL150_/)),
        // Use a Cache First caching strategy
        new CacheFirst({
          // Put all cached files in a cache named 'images'
          cacheName: 'images',
          plugins: [
            // Ensure that only requests that result in a 200 status are cached
            new CacheableResponsePlugin({
              statuses: [200],
            }),
            // Don't cache more than 50 items, and expire them after 30 days
            new ExpirationPlugin({
              maxEntries: 50,
              maxAgeSeconds: 60 * 60 * 24 * 30, // 30 Days
            }),
          ],
        }),
      );

      // Cache the Google Fonts stylesheets with a stale-while-revalidate strategy.
      registerRoute(
        ({url}) => url.origin === 'https://fonts.googleapis.com',
        new StaleWhileRevalidate({
          cacheName: 'google-fonts-stylesheets',
        })
      );

      // Cache the underlying font files with a cache-first strategy for 1 year.
      registerRoute(
        ({url}) => url.origin === 'https://fonts.gstatic.com',
        new CacheFirst({
          cacheName: 'google-fonts-webfonts',
          plugins: [
            new CacheableResponsePlugin({
              statuses: [0, 200],
            }),
            new ExpirationPlugin({
              maxAgeSeconds: 60 * 60 * 24 * 365,
              maxEntries: 30,
            }),
          ],
        })
      );
      `;
    },
    runCachebuster: function() {
      return new Date().getTime();
    }
  }
};
const _withScopeId$2 = (n) => (pushScopeId("data-v-93bb04d6"), n = n(), popScopeId(), n);
const _hoisted_1$9 = { class: "export-group" };
const _hoisted_2$9 = { class: "top-wrapper" };
const _hoisted_3$8 = {
  class: "text-wrapper",
  ref: "textWrapper"
};
const _hoisted_4$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("h2", null, "Stand-alone gallery", -1));
const _hoisted_5$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "description" }, " This saves the gallery as a web page that can be uploaded online and shared with others. ", -1));
const _hoisted_6$1 = [
  _hoisted_4$3,
  _hoisted_5$2
];
const _hoisted_7$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("h3", null, "Include:", -1));
const _hoisted_8$1 = { class: "options opt-groups" };
const _hoisted_9$1 = ["data-extra", "content"];
const _hoisted_10$1 = ["disabled", "onUpdate:modelValue", "onChange"];
const _hoisted_11$1 = { class: "visual-checkbox" };
const _hoisted_12$1 = { class: "icon" };
const _hoisted_13$1 = { class: "buttons-footer" };
const _hoisted_14$1 = { class: "btn-wrapper" };
const _hoisted_15$1 = {
  key: 0,
  style: { "color": "#999", "font-weight": "bold", "margin-bottom": "5px" }
};
const _hoisted_16$1 = /* @__PURE__ */ createTextVNode(" Saving the standalone gallery is only possible ");
const _hoisted_17$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("br", null, null, -1));
const _hoisted_18$1 = /* @__PURE__ */ createTextVNode(' in "production" builds (');
const _hoisted_19$1 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("code", null, "yarn vite build", -1));
const _hoisted_20$1 = /* @__PURE__ */ createTextVNode(") ");
const _hoisted_21$1 = [
  _hoisted_16$1,
  _hoisted_17$1,
  _hoisted_18$1,
  _hoisted_19$1,
  _hoisted_20$1
];
const _hoisted_22$1 = ["disabled"];
const _hoisted_23$1 = { key: 0 };
const _hoisted_24$1 = /* @__PURE__ */ createTextVNode(" ALE-gallery.zip");
const _hoisted_25$1 = {
  class: "github-btn",
  target: "_blank",
  rel: "noopener noreferrer",
  href: "https://joonaspaakko.gitbook.io/audible-library-extractor/sharing/uploading-to-github"
};
const _hoisted_26 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", null, "Upload instructions", -1));
const _hoisted_27 = {
  class: "github-btn",
  target: "_blank",
  rel: "noopener noreferrer",
  href: "https://joonaspaakko.gitbook.io/audible-library-extractor/sharing/uploading-to-github/updating-gallery-in-github"
};
const _hoisted_28 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("span", null, "Update instructions", -1));
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ep_grid = __unplugin_components_0$6;
  const _component_fa_solid_check = __unplugin_components_5;
  const _component_line_md_downloading_loop = __unplugin_components_2$1;
  const _component_fa6_solid_download = __unplugin_components_3;
  const _component_octicon_mark_github_16 = __unplugin_components_4$1;
  const _component_gallery_modal = __unplugin_components_1$2;
  const _directive_tippy = resolveDirective("tippy");
  return openBlock(), createBlock(_component_gallery_modal, {
    onCloseModal: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("closeComp"))
  }, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$9, [
        createBaseVNode("div", _hoisted_2$9, [
          createBaseVNode("div", {
            class: "icon-wrapper",
            style: normalizeStyle({ fontSize: _ctx.iconSize / 1.2 + "px", lineHeight: _ctx.iconSize / 1.2 + "px", paddingRight: _ctx.iconSize / 2.5 + "px" })
          }, [
            createVNode(_component_ep_grid)
          ], 4),
          createBaseVNode("div", _hoisted_3$8, _hoisted_6$1, 512)
        ]),
        _hoisted_7$1,
        createBaseVNode("div", _hoisted_8$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($options.chunkSource, (group, groupIndex) => {
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(["opt-group", ["group-" + groupIndex]]),
              key: groupIndex
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(group, (item, itemIndex) => {
                return withDirectives((openBlock(), createElementBlock("label", {
                  class: normalizeClass(["item-" + itemIndex, item.disabled ? "disabled" : null]),
                  "data-extra": item.extra,
                  key: item.key,
                  content: item.tippy
                }, [
                  withDirectives(createBaseVNode("input", {
                    type: "checkbox",
                    disabled: item.disabled,
                    "onUpdate:modelValue": ($event) => item.checked = $event,
                    onChange: ($event) => $options.sourceChecked($event, item)
                  }, null, 40, _hoisted_10$1), [
                    [vModelCheckbox, item.checked]
                  ]),
                  createBaseVNode("div", _hoisted_11$1, [
                    createBaseVNode("span", _hoisted_12$1, [
                      createVNode(_component_fa_solid_check)
                    ])
                  ]),
                  createBaseVNode("span", null, toDisplayString(item.key), 1)
                ], 10, _hoisted_9$1)), [
                  [_directive_tippy]
                ]);
              }), 128))
            ], 2);
          }), 128))
        ]),
        createBaseVNode("div", _hoisted_13$1, [
          createBaseVNode("div", _hoisted_14$1, [
            _ctx.$store.state.devMode ? (openBlock(), createElementBlock("div", _hoisted_15$1, _hoisted_21$1)) : createCommentVNode("", true),
            createBaseVNode("button", {
              class: normalizeClass(["save-btn save-gallery", { saving: _ctx.bundling }]),
              onClick: _cache[1] || (_cache[1] = (...args) => $options.saveButtonClicked && $options.saveButtonClicked(...args)),
              disabled: !_ctx.$store.state.devMode && (_ctx.bundling || !_ctx.saveBtnEnabled)
            }, [
              createBaseVNode("span", null, [
                _ctx.bundling ? (openBlock(), createElementBlock("strong", _hoisted_23$1, "Packaging:")) : createCommentVNode("", true),
                _hoisted_24$1
              ]),
              _ctx.bundling ? (openBlock(), createBlock(_component_line_md_downloading_loop, { key: 0 })) : (openBlock(), createBlock(_component_fa6_solid_download, { key: 1 })),
              _ctx.bundling && _ctx.progressWidth ? (openBlock(), createElementBlock("div", {
                key: 2,
                class: "progress",
                style: normalizeStyle({ width: _ctx.progressWidth })
              }, null, 4)) : createCommentVNode("", true),
              _ctx.bundling ? (openBlock(), createElementBlock("button", {
                key: 3,
                class: "cancel-packaging",
                onClick: _cache[0] || (_cache[0] = (...args) => $options.cancelZipping && $options.cancelZipping(...args))
              }, "cancel")) : createCommentVNode("", true)
            ], 10, _hoisted_22$1),
            createBaseVNode("div", null, [
              createBaseVNode("a", _hoisted_25$1, [
                _hoisted_26,
                createVNode(_component_octicon_mark_github_16)
              ]),
              createBaseVNode("a", _hoisted_27, [
                _hoisted_28,
                createVNode(_component_octicon_mark_github_16)
              ])
            ])
          ])
        ])
      ])
    ]),
    _: 1
  });
}
var saveGallery = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-93bb04d6"]]);
const _hoisted_1$8 = {
  viewBox: "0 0 576 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$8 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M384 24c0-9.6 5.7-18.2 14.5-22s19-2 26 4.6l144 136c4.8 4.5 7.5 10.8 7.5 17.4s-2.7 12.9-7.5 17.4l-144 136c-7 6.6-17.2 8.4-26 4.6S384 305.5 384 296v-72h-46.5c-45 0-81.5 36.5-81.5 81.5c0 22.3 10.3 34.3 19.2 40.5c6.8 4.7 12.8 12 12.8 20.3c0 9.8-8 17.8-17.8 17.8h-2.5c-2.4 0-4.8-.4-7.1-1.4C242.8 374.8 160 333.4 160 240c0-79.5 64.5-144 144-144h80V24zM0 144c0-44.2 35.8-80 80-80h16c17.7 0 32 14.3 32 32s-14.3 32-32 32H80c-8.8 0-16 7.2-16 16v288c0 8.8 7.2 16 16 16h288c8.8 0 16-7.2 16-16v-16c0-17.7 14.3-32 32-32s32 14.3 32 32v16c0 44.2-35.8 80-80 80H80c-44.2 0-80-35.8-80-80V144z"
}, null, -1);
const _hoisted_3$7 = [
  _hoisted_2$8
];
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_3$7);
}
var __unplugin_components_4 = { name: "fa6-solid-share-from-square", render: render$3 };
const _hoisted_1$7 = {
  viewBox: "0 0 512 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M222.7 32.1c5 16.9-4.6 34.8-21.5 39.8C121.8 95.6 64 169.1 64 256c0 106 86 192 192 192s192-86 192-192c0-86.9-57.8-160.4-137.1-184.1c-16.9-5-26.6-22.9-21.5-39.8s22.9-26.6 39.8-21.5C434.9 42.1 512 140 512 256c0 141.4-114.6 256-256 256S0 397.4 0 256C0 140 77.1 42.1 182.9 10.6c16.9-5 34.8 4.6 39.8 21.5z"
}, null, -1);
const _hoisted_3$6 = [
  _hoisted_2$7
];
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$7, _hoisted_3$6);
}
var __unplugin_components_2 = { name: "fa6-solid-circle-notch", render: render$2 };
const _hoisted_1$6 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10s10-4.47 10-10S17.53 2 12 2z"
}, null, -1);
const _hoisted_3$5 = [
  _hoisted_2$6
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$6, _hoisted_3$5);
}
var __unplugin_components_1$1 = { name: "ic-baseline-circle", render: render$1 };
const _hoisted_1$5 = {
  viewBox: "0 0 384 512",
  width: "1.2em",
  height: "1.2em"
};
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M64 0C28.7 0 0 28.7 0 64v384c0 35.3 28.7 64 64 64h256c35.3 0 64-28.7 64-64V160H256c-17.7 0-32-14.3-32-32V0H64zm192 0v128h128L256 0zM80 224h16c22.1 0 40 17.9 40 40v8c0 8.8-7.2 16-16 16s-16-7.2-16-16v-8c0-4.4-3.6-8-8-8H80c-4.4 0-8 3.6-8 8v80c0 4.4 3.6 8 8 8h16c4.4 0 8-3.6 8-8v-8c0-8.8 7.2-16 16-16s16 7.2 16 16v8c0 22.1-17.9 40-40 40H80c-22.1 0-40-17.9-40-40v-80c0-22.1 17.9-40 40-40zm72 46.4c0-25.6 20.8-46.4 46.4-46.4H216c8.8 0 16 7.2 16 16s-7.2 16-16 16h-17.6c-7.9 0-14.4 6.4-14.4 14.4c0 5.2 2.8 9.9 7.2 12.5l25.4 14.5C231 305.7 240 321 240 337.7c0 25.6-20.8 46.4-46.4 46.4H168c-8.8 0-16-7.2-16-16s7.2-16 16-16h25.6c7.9 0 14.4-6.4 14.4-14.4c0-5.2-2.8-9.9-7.2-12.5l-25.4-14.5c-14.5-8.3-23.4-23.7-23.4-40.3zM280 240v31.6c0 23 5.5 45.6 16 66c10.5-20.3 16-42.9 16-66V240c0-8.8 7.2-16 16-16s16 7.2 16 16v31.6c0 34.7-10.3 68.7-29.6 97.6l-5.1 7.7c-3 4.5-8 7.1-13.3 7.1s-10.3-2.7-13.3-7.1l-5.1-7.7c-19.3-28.9-29.6-62.9-29.6-97.6V240c0-8.8 7.2-16 16-16s16 7.2 16 16z"
}, null, -1);
const _hoisted_3$4 = [
  _hoisted_2$5
];
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$5, _hoisted_3$4);
}
var __unplugin_components_0$1 = { name: "fa6-solid-file-csv", render };
var stringifyArray = {
  methods: {
    stringifyArray: function(array, key, delim) {
      if (!Array.isArray(array)) {
        return array || "";
      } else {
        if (key)
          return array.map(function(o) {
            return o[key];
          }).join(delim || ", ");
        else
          return array.join(", ");
      }
    }
  }
};
var makeFullUrl = {
  methods: {
    makeFullUrl: function(inputURL) {
      const url = new Url(this.$store.state.urlOrigin + inputURL);
      url.query.ipRedirectOverride = true;
      url.query.overrideBaseCountry = true;
      return url.toString();
    },
    makeUrl: function(type, input) {
      const base2 = this.$store.state.urlOrigin;
      let newUrl = "";
      switch (type) {
        case "store":
        case "book":
          newUrl = base2 + "/pd/" + encodeURIComponent(input);
          break;
        case "author":
          if (input.url)
            newUrl = base2 + "/author/" + input.url;
          else
            newUrl = base2 + "/search?searchAuthor=" + encodeURIComponent(input.name);
          break;
        case "narrator":
          if (input.name)
            newUrl = base2 + "/search?searchNarrator=" + encodeURIComponent(input.name);
          break;
        case "series":
          if (input.asin)
            newUrl = base2 + "/series/" + input.asin;
          break;
        case "publisher":
          if (input.name)
            newUrl = base2 + "/search?searchProvider=" + encodeURIComponent(input.name);
          break;
        case "categories":
        case "tags":
          if (input.url)
            newUrl = base2 + "/cat/" + input.url;
          break;
      }
      if (!newUrl) {
        return "";
      } else {
        let url = new Url(newUrl);
        url.query.ipRedirectOverride = true;
        url.query.overrideBaseCountry = true;
        return url.toString();
      }
    }
  }
};
var prepareKeys = {
  methods: {
    prepareKeys: function(config) {
      config = config || {};
      let collection = config.collection || _.get(this.$store.state, this.$store.state.collectionSource);
      let keys = _.union(_.flatten(_.map(collection, (e) => _.keys(e))));
      keys = keys.concat([
        "isbn10",
        "isbn13"
      ]);
      let priorityKeys = [
        "added",
        "title",
        "series",
        "bookNumbers",
        "authors",
        "narrators",
        "tags",
        "categories",
        "length",
        "progress",
        "releaseDate",
        "publishers",
        "myRating",
        "rating",
        "ratings",
        "favorite",
        "format",
        "language",
        "whispersync",
        "fromPlusCatalog",
        "unavailable",
        "archived",
        "downloaded",
        "storePageChanged",
        "storePageMissing"
      ];
      if (config.priorityKeys)
        priorityKeys = config.priorityKeys;
      let leftoverKeys = _.remove(keys, function(key) {
        return !_.includes(priorityKeys, key);
      });
      keys = priorityKeys.concat(leftoverKeys);
      priorityKeys = null;
      leftoverKeys = null;
      let removeKeys = [
        "titleShort",
        "sample",
        "blurb",
        "url",
        "summary",
        "moreLikeThis",
        "peopleAlsoBought",
        "asin",
        "cover",
        "sample",
        "cover",
        "isbns"
      ];
      keys = _.remove(keys, function(key) {
        return !_.includes(config.removeKeys || removeKeys, key);
      });
      return keys;
    }
  }
};
var slugify = {
  methods: {
    slugify: function(string) {
      const a = "\xE0\xE1\xE2\xE4\xE6\xE3\xE5\u0101\u0103\u0105\xE7\u0107\u010D\u0111\u010F\xE8\xE9\xEA\xEB\u0113\u0117\u0119\u011B\u011F\u01F5\u1E27\xEE\xEF\xED\u012B\u012F\xEC\u0142\u1E3F\xF1\u0144\u01F9\u0148\xF4\xF6\xF2\xF3\u0153\xF8\u014D\xF5\u0151\u1E55\u0155\u0159\xDF\u015B\u0161\u015F\u0219\u0165\u021B\xFB\xFC\xF9\xFA\u016B\u01D8\u016F\u0171\u0173\u1E83\u1E8D\xFF\xFD\u017E\u017A\u017C\xB7/_,:;";
      const b = "aaaaaaaaaacccddeeeeeeeegghiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz------";
      const p = new RegExp(a.split("").join("|"), "g");
      return encodeURIComponent(
        string.toString().toLowerCase().replace(/\s+/g, "-").replace(p, (c) => b.charAt(a.indexOf(c))).replace(/&/g, "-and-").replace(/[^\w\-]+/g, "").replace(/\-\-+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
      );
    }
  }
};
var makeGoodReadsUrl = {
  methods: {
    makeGoodReadsUrl: function(book) {
      book = book || this.book;
      const author = book.authors ? book.authors[0].name + " - " : book.obj && book.obj.authors ? book.obj.authors[0].name + " - " : "";
      let title = (author && book.titleShort ? book.titleShort : book.title) || "";
      const searchQuery = author + title;
      if (book.titleShort || book.title) {
        return "https://www.goodreads.com/search?q=" + encodeURIComponent(searchQuery);
      } else {
        return null;
      }
    }
  }
};
var saveCsv_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$4 = {
  name: "saveCsv",
  mixins: [
    stringifyArray,
    makeCoverUrl,
    makeFullUrl,
    prepareKeys,
    slugify,
    makeGoodReadsUrl
  ],
  components: {
    modal: __unplugin_components_1$2
  },
  data: function() {
    return {
      settings: {
        dataSourcesChecked: "Library",
        dataSources: [
          { key: "Library", description: "Export library data as spreadsheet. Default sorting (added): new books at the top." },
          { key: "Wishlist", description: "Export wishlist data as spreadsheet.  Default sorting (added): new books at the top." },
          { key: "Current page", description: "Export contents from any page with books. Search, filtering, and sorting affect this source." }
        ],
        compatibilityChecked: "Google Sheets",
        compatibility: [
          { key: "Raw data", label: "Raw data", description: "Raw data with no special formulas, so it will work in any spreadsheet application." },
          { key: "Google Sheets", description: `Adds Google Sheets compatible formulas that add icons and links. If you don't like the formulas, you can use "raw data" instead.` },
          { key: "Goodreads", description: "This spreadsheet includes Goodreads relevant columns and removes any books that don't have ISBNs since Goodreads won't import books without them. Book status determines the bookshelve: not started (to-read), started(currently-reading), finished (read). Book categories are divided into shelves as well." }
        ]
      },
      bundling: false,
      iconSize: 20
    };
  },
  mounted: function() {
    if (this.$store.state.sticky.exportSettingsCSVdataSources) {
      this.settings.dataSourcesChecked = this.$store.state.sticky.exportSettingsCSVdataSources;
    }
    if (this.$store.state.sticky.exportSettingsCSVcompatibility) {
      this.settings.compatibilityChecked = this.$store.state.sticky.exportSettingsCSVcompatibility;
    }
    this.iconSize = this.$refs.textWrapper.offsetHeight;
  },
  computed: {
    dataSourceActive() {
      return _.find(this.settings.dataSources, { key: this.settings.dataSourcesChecked });
    },
    compatibilityActive() {
      return _.find(this.settings.compatibility, { key: this.settings.compatibilityChecked });
    },
    googleSheets: function() {
      return this.settings.compatibilityChecked === "Google Sheets";
    },
    filename: function() {
      let suffix = "";
      if (this.settings.dataSourcesChecked === "Library") {
        suffix = "library";
      } else if (this.settings.dataSourcesChecked === "Wishlist") {
        suffix = "wishlist";
      } else if (this.settings.dataSourcesChecked === "Current page") {
        let pageTitle = this.$store.state.pageTitle ? this.slugify(this.$store.state.pageTitle) : null;
        let routeName = this.$route.name;
        suffix = pageTitle || routeName;
      }
      if (suffix !== "")
        suffix = "-" + suffix;
      return "ALE-spreadsheet" + suffix + ".csv";
    },
    dataSource: function() {
      switch (this.settings.dataSourcesChecked) {
        case "Library":
          return this.$store.state.library.books;
        case "Wishlist":
          return this.$store.state.library.wishlist;
        case "Current page":
          return this.$store.getters.collection;
      }
    },
    saveBtnEnabled: function() {
      if (this.settings.dataSourcesChecked === "Current page") {
        if (this.$route.meta.gallery)
          return true;
      } else if (this.settings.dataSourcesChecked === "Wishlist" && this.settings.compatibilityChecked === "Goodreads") {
        return false;
      } else {
        return this.dataSource && this.dataSource.length > 0;
      }
    }
  },
  methods: {
    saveButtonClicked: function() {
      if (!this.bundling) {
        const vue = this;
        vue.bundling = true;
        let dataSource = JSON.parse(JSON.stringify(this.dataSource));
        let keys = this.prepKeys(dataSource);
        let csv = Papa.unparse({
          fields: _.map(keys, function(key) {
            return key === "isbn10" && key === "isbn13" ? key.toUpperCase() : _.startCase(key);
          }),
          data: this.processData(keys, dataSource),
          quotes: false,
          quoteChar: '"',
          escapeChar: '"',
          delimiter: ",",
          header: true,
          newline: "\r\n",
          skipEmptyLines: false,
          columns: null
        });
        saveAs(new File([csv], this.filename, { type: "text/csv;charset=utf-8" }));
        setTimeout(function() {
          vue.bundling = false;
        }, 1e3);
      }
    },
    inputChanged: function(e) {
      if (this.$store.state.sticky.exportSettingsCSVdataSources !== this.settings.dataSourcesChecked) {
        this.$store.commit("stickyProp", { key: "exportSettingsCSVdataSources", value: this.settings.dataSourcesChecked });
      }
      if (this.$store.state.sticky.exportSettingsCSVcompatibility !== this.settings.compatibilityChecked) {
        this.$store.commit("stickyProp", { key: "exportSettingsCSVcompatibility", value: this.settings.compatibilityChecked });
      }
    },
    processData: function(keys, dataSource) {
      let vue = this;
      if (this.$store.state.sticky.exportSettingsCSVcompatibility === "Goodreads") {
        return this.processDataGoodreads(keys, dataSource);
      } else {
        return _.map(dataSource, function(book) {
          return _.map(keys, function(key) {
            switch (key) {
              case "authors":
              case "narrators":
              case "categories":
              case "publishers":
              case "tags":
                return vue.stringifyArray(book[key], "name", key === "categories" ? " > " : null) || "";
              case "series":
                let series = book.series;
                if (series)
                  series = _.map(series, function(series2) {
                    let numbers = series2.bookNumbers ? " (book " + series2.bookNumbers.join(", ") + ")" : "";
                    return series2.name + numbers;
                  }).join(", ");
                return series;
              case "bookNumbers":
                let allNumbers = _.filter(book.series, "bookNumbers");
                allNumbers = _.map(allNumbers, "bookNumbers");
                allNumbers = _.flatten(allNumbers);
                if (_.isEmpty(allNumbers))
                  allNumbers = null;
                else if (_.isArray(allNumbers)) {
                  allNumbers = allNumbers.join(", ");
                }
                allNumbers = allNumbers || "\u221E";
                if (vue.googleSheets)
                  allNumbers = "'" + allNumbers;
                return book.series ? allNumbers : "";
              case "isbn10":
                const isbn10 = _.find(book.isbns, { type: "ISBN_10" });
                if (isbn10) {
                  if (vue.googleSheets)
                    return "'" + isbn10.identifier;
                  else
                    return isbn10.identifier;
                } else {
                  return "";
                }
              case "isbn13":
                const isbn13 = _.find(book.isbns, { type: "ISBN_13" });
                if (isbn13) {
                  if (vue.googleSheets)
                    return "'" + isbn13.identifier;
                  else
                    return isbn13.identifier;
                } else {
                  return "";
                }
              case "peopleAlsoBought":
                if (book.peopleAlsoBought)
                  return vue.stringifyArray(book.peopleAlsoBought, "title");
                else {
                  return "";
                }
              case "summary":
                return book.summary ? book.summary.replace(/(\n|\r)/g) : "";
              case "cover":
                let cover = !book.cover ? "" : vue.makeCoverUrl(book.cover);
                if (book.cover && cover && book.asin && vue.googleSheets) {
                  cover = vue.googleSheetsLinkifyImage(vue.makeUrl("book", book.asin), vue.makeCoverUrl(book.cover, 75), 0);
                }
                return cover;
              case "title":
                let title = book[key] || book.titleShort || "";
                if (title && book.asin && vue.googleSheets) {
                  title = vue.googleSheetsLinkify(title, vue.makeUrl("book", book.asin));
                }
                return title;
              case "titleShort":
                let titleShort = book[key] || book.title || "";
                if (titleShort && book.asin && vue.googleSheets) {
                  titleShort = vue.googleSheetsLinkify(titleShort, vue.makeUrl("book", book.asin));
                }
                return titleShort;
              case "sample":
                let sample = book[key] || "";
                if (sample && vue.googleSheets) {
                  sample = vue.googleSheetsLinkifyImage(sample, "https://i.imgur.com/R2N6OTy.png", 20);
                }
                return sample;
              case "searchInGoodreads":
                let goodreadsSearch = vue.makeGoodReadsUrl(book);
                if (goodreadsSearch && vue.googleSheets)
                  goodreadsSearch = vue.googleSheetsLinkifyImage(goodreadsSearch, "https://i.imgur.com/RPJRqNX.png", 20);
                return goodreadsSearch || "";
              case "webPlayer":
                let webPlayerURL = book.asin ? "https://www.audible.com/webplayer?asin=" + book.asin : "";
                if (webPlayerURL && vue.googleSheets)
                  webPlayerURL = vue.googleSheetsLinkifyImage(webPlayerURL, "https://i.imgur.com/PdFLCdl.png", 20);
                return webPlayerURL || "";
              case "parentCategory":
                return book.categories && book.categories[0] ? book.categories[0].name : "";
              case "childCategory":
                return book.categories && book.categories[1] ? book.categories[1].name : "";
              case "storePage":
                return book.asin ? vue.makeUrl("book", book.asin) : "";
              case "asin":
              case "length":
              case "progress":
              case "myRating":
              case "rating":
              case "ratings":
              case "isbn":
              case "isbn10":
              case "isbn13":
                if (vue.googleSheets)
                  return "'" + (book[key] || "");
                else
                  return book[key] || "";
              case "storePageUrl":
                return book.asin ? vue.makeUrl("book", book.asin) : "";
              default:
                return book[key] || "";
            }
          });
        });
      }
    },
    googleSheetsLinkify: function(string, url) {
      return '=HYPERLINK("' + url + '";"' + string.replace(/\"/g, '""') + '")';
    },
    googleSheetsLinkifyImage: function(url, image, size) {
      size = size || 0;
      let sizeString = size ? "; 4; " + size + "; " + size : "";
      return '=HYPERLINK("' + url + '"; IMAGE("' + image + '"' + sizeString + "))";
    },
    googleSheetsImagefy: function(url, size) {
      size = size || 0;
      let sizeString = size ? "; 4; " + size + "; " + size : "";
      return '=IMAGE("' + url + '"' + sizeString + ")";
    },
    processDataGoodreads: function(keys, dataSource) {
      let vue = this;
      dataSource = _.filter(dataSource, function(book) {
        const isbn10 = _.find(book.isbns, { type: "ISBN_10" });
        const isbn13 = _.find(book.isbns, { type: "ISBN_13" });
        return isbn10 || isbn13;
      });
      return _.map(dataSource, function(book) {
        return _.map(keys, function(key) {
          switch (key) {
            case "title":
              return book.title || book.titleShort || "";
            case "author":
            case "publisher":
              if (book[key + "s"])
                return vue.stringifyArray([book[key + "s"][0]], "name") || "";
              else {
                return "";
              }
            case "myRating":
              return book.myRating || "";
            case "binding":
              return "Audible Audio";
            case "yearPublished":
              return book.releaseDate || "";
            case "dateAdded":
              let date = new Date();
              let offset = date.getTimezoneOffset();
              date = new Date(date.getTime() - offset * 60 * 1e3);
              return date.toISOString().split("T")[0];
            case "bookshelves":
              let shelves = [];
              let notStarted = !book.progress;
              let started = book.progress && !book.progress.toLowerCase().match("finished") ? true : false;
              let finished = book.progress && book.progress.toLowerCase().match("finished") ? true : false;
              let status = notStarted ? "to-read" : started ? "currently-reading" : finished ? "read" : "to-read";
              shelves.push(status);
              shelves.push("audible");
              shelves.push("audiobook");
              if (book.fromPlusCatalog)
                shelves.push("audible-plus");
              let parentCategory = book.categories && book.categories[0] ? book.categories[0].name : null;
              if (parentCategory)
                shelves.push(vue.slugify(parentCategory));
              let childCategory = book.categories && book.categories[1] ? book.categories[1].name : null;
              if (childCategory)
                shelves.push(vue.slugify(childCategory));
              return shelves.join(" ");
            case "isbn":
              const isbn10 = _.find(book.isbns, { type: "ISBN_10" });
              if (isbn10)
                return isbn10.identifier;
              else {
                return "";
              }
            case "isbn13":
              const isbn13 = _.find(book.isbns, { type: "ISBN_13" });
              if (isbn13)
                return isbn13.identifier;
              else {
                return "";
              }
            default:
              return "";
          }
        });
      });
    },
    prepKeys: function(dataSource) {
      let keys = [];
      switch (this.settings.compatibilityChecked) {
        case "Google Sheets":
        case "Raw data":
          let priorityKeys = [
            "added",
            "cover",
            "sample",
            "webPlayer",
            "searchInGoodreads",
            "title",
            "titleShort",
            "series",
            "bookNumbers",
            "blurb",
            "authors",
            "narrators",
            "tags",
            "categories",
            "parentCategory",
            "childCategory",
            "length",
            "progress",
            "releaseDate",
            "publishers",
            "myRating",
            "rating",
            "ratings",
            "favorite",
            "format",
            "language",
            "whispersync",
            "fromPlusCatalog",
            "unavailable",
            "archived",
            "downloaded",
            "storePageChanged",
            "storePageMissing",
            "asin",
            "isbn10",
            "isbn13",
            "summary",
            "peopleAlsoBought"
          ];
          const rawData = this.settings.compatibilityChecked === "Raw data";
          if (rawData)
            priorityKeys.push("storePageUrl");
          if (rawData) {
            var hyperlinkKeys = [
              "sample",
              "webPlayer",
              "cover",
              "searchInGoodreads"
            ];
            priorityKeys = _.remove(priorityKeys, function(key) {
              return !_.includes(hyperlinkKeys, key);
            });
            priorityKeys = priorityKeys.concat(hyperlinkKeys);
          }
          keys = this.prepareKeys({
            collection: dataSource || [],
            removeKeys: ["isbns"],
            priorityKeys
          });
          break;
        case "Goodreads":
          keys = ["dateRead", "myReview", "title", "bookshelves", "author", "publisher", "myRating", "binding", "yearPublished", "dateAdded", "isbn", "isbn13"];
          break;
      }
      return keys;
    }
  }
};
const _withScopeId$1 = (n) => (pushScopeId("data-v-aac578c4"), n = n(), popScopeId(), n);
const _hoisted_1$4 = { class: "export-group" };
const _hoisted_2$4 = { class: "top-wrapper" };
const _hoisted_3$3 = {
  class: "text-wrapper",
  ref: "textWrapper"
};
const _hoisted_4$2 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h2", null, " CSV (Spreadsheet)", -1));
const _hoisted_5$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "description" }, " CSV is a generic file format for tabular data that is supported by any proper spreadsheet application. ", -1));
const _hoisted_6 = [
  _hoisted_4$2,
  _hoisted_5$1
];
const _hoisted_7 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h3", null, "Data source:", -1));
const _hoisted_8 = { class: "options" };
const _hoisted_9 = ["value"];
const _hoisted_10 = { class: "visual-radiobutton" };
const _hoisted_11 = { class: "icon" };
const _hoisted_12 = {
  class: "description",
  style: { "margin-top": "10px" }
};
const _hoisted_13 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("h3", null, "Format:", -1));
const _hoisted_14 = { class: "options" };
const _hoisted_15 = ["value"];
const _hoisted_16 = { class: "visual-radiobutton" };
const _hoisted_17 = { class: "icon" };
const _hoisted_18 = {
  class: "description",
  style: { "margin-top": "10px" }
};
const _hoisted_19 = { class: "buttons-footer" };
const _hoisted_20 = { class: "btn-wrapper" };
const _hoisted_21 = ["disabled"];
const _hoisted_22 = {
  class: "github-btn",
  target: "_blank",
  rel: "noopener noreferrer",
  href: "https://joonaspaakko.gitbook.io/audible-library-extractor/gallery/csv-export/google-sheets-import"
};
const _hoisted_23 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "Google Sheets import", -1));
const _hoisted_24 = {
  class: "github-btn",
  target: "_blank",
  rel: "noopener noreferrer",
  href: "https://joonaspaakko.gitbook.io/audible-library-extractor/gallery/csv-export/goodreads-import"
};
const _hoisted_25 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", null, "Goodreads import", -1));
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_fa6_solid_file_csv = __unplugin_components_0$1;
  const _component_ic_baseline_circle = __unplugin_components_1$1;
  const _component_fa6_solid_circle_notch = __unplugin_components_2;
  const _component_fa6_solid_download = __unplugin_components_3;
  const _component_fa6_solid_share_from_square = __unplugin_components_4;
  const _component_gallery_modal = __unplugin_components_1$2;
  return openBlock(), createBlock(_component_gallery_modal, {
    onCloseModal: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("closeComp"))
  }, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$4, [
        createBaseVNode("div", _hoisted_2$4, [
          createBaseVNode("div", {
            class: "icon-wrapper",
            style: normalizeStyle({ fontSize: _ctx.iconSize / 1.2 + "px", lineHeight: _ctx.iconSize / 1.2 + "px", paddingRight: _ctx.iconSize / 2.5 + "px" })
          }, [
            createVNode(_component_fa6_solid_file_csv)
          ], 4),
          createBaseVNode("div", _hoisted_3$3, _hoisted_6, 512)
        ]),
        _hoisted_7,
        createBaseVNode("div", _hoisted_8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.settings.dataSources, (source) => {
            return openBlock(), createElementBlock("label", {
              key: source.key
            }, [
              withDirectives(createBaseVNode("input", {
                type: "radio",
                name: "dataSources",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.settings.dataSourcesChecked = $event),
                value: source.key,
                onChange: _cache[1] || (_cache[1] = (...args) => $options.inputChanged && $options.inputChanged(...args))
              }, null, 40, _hoisted_9), [
                [vModelRadio, _ctx.settings.dataSourcesChecked]
              ]),
              createBaseVNode("div", _hoisted_10, [
                createBaseVNode("div", _hoisted_11, [
                  createVNode(_component_ic_baseline_circle)
                ])
              ]),
              createBaseVNode("span", null, toDisplayString(source.key), 1)
            ]);
          }), 128))
        ]),
        createBaseVNode("div", _hoisted_12, toDisplayString($options.dataSourceActive.description), 1),
        _hoisted_13,
        createBaseVNode("div", _hoisted_14, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.settings.compatibility, (item) => {
            return openBlock(), createElementBlock("label", {
              key: item.key
            }, [
              withDirectives(createBaseVNode("input", {
                type: "radio",
                name: "compatibility",
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.settings.compatibilityChecked = $event),
                value: item.key,
                onChange: _cache[3] || (_cache[3] = (...args) => $options.inputChanged && $options.inputChanged(...args))
              }, null, 40, _hoisted_15), [
                [vModelRadio, _ctx.settings.compatibilityChecked]
              ]),
              createBaseVNode("div", _hoisted_16, [
                createBaseVNode("div", _hoisted_17, [
                  createVNode(_component_ic_baseline_circle)
                ])
              ]),
              createBaseVNode("span", null, toDisplayString(item.label || item.key), 1)
            ]);
          }), 128))
        ]),
        createBaseVNode("div", _hoisted_18, toDisplayString($options.compatibilityActive.description), 1),
        createBaseVNode("div", _hoisted_19, [
          createBaseVNode("div", _hoisted_20, [
            createBaseVNode("button", {
              class: normalizeClass(["save-btn save-csv", { saving: _ctx.bundling }]),
              onClick: _cache[4] || (_cache[4] = (...args) => $options.saveButtonClicked && $options.saveButtonClicked(...args)),
              disabled: _ctx.bundling || !$options.saveBtnEnabled
            }, [
              createBaseVNode("span", null, toDisplayString($options.filename), 1),
              _ctx.bundling ? (openBlock(), createBlock(_component_fa6_solid_circle_notch, {
                key: 0,
                spin: ""
              })) : (openBlock(), createBlock(_component_fa6_solid_download, { key: 1 }))
            ], 10, _hoisted_21),
            createBaseVNode("div", null, [
              createBaseVNode("a", _hoisted_22, [
                _hoisted_23,
                createVNode(_component_fa6_solid_share_from_square)
              ]),
              createBaseVNode("a", _hoisted_24, [
                _hoisted_25,
                createVNode(_component_fa6_solid_share_from_square)
              ])
            ])
          ])
        ])
      ])
    ]),
    _: 1
  });
}
var saveCSV = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-aac578c4"]]);
var galleryNavigation_vue_vue_type_style_index_0_lang = "";
const _sfc_main$3 = {
  name: "aleMenuActions",
  data: function() {
    return {
      store: this.$store.state,
      mobileMenuOpen: false,
      sampleData: null,
      subMenuActive: null,
      routeAvailable: {},
      loading: true,
      routes: null,
      clickedRoute: null
    };
  },
  computed: {
    clickedRouteComp() {
      const component = _.get(this.clickedRoute, "meta.component");
      if (component) {
        return { ...component };
      }
    },
    mobileThreshold() {
      return this.$store.getters.mobileThreshold;
    }
  },
  watch: {
    "$store.state.playingAudio": function() {
      this.globalTopNavHeight(this.mobileSize);
    },
    mobileThreshold(mobileSize) {
      this.mobileMenuOpen = false;
      this.routes = this.getRoutes();
      this.globalTopNavHeight(mobileSize);
    },
    mobileMenuOpen(open) {
      this.$store.commit("prop", { key: "preventScrolling", value: open });
      this.routes = this.getRoutes();
    },
    clickedRouteComp(open) {
      this.$store.commit("prop", { key: "preventScrolling", value: open });
    }
  },
  created() {
    this.routes = this.getRoutes();
  },
  mounted: function() {
    this.loading = false;
    this.globalTopNavHeight(this.mobileSize);
  },
  beforeUnmount: function() {
  },
  methods: {
    startSearching() {
      this.$compEmitter.emit("ios-auto-zoom-disable");
      this.$compEmitter.emit("search-focus");
    },
    getRoutes() {
      let routes = _.filter(this.$router.options.routes, "meta.icon");
      routes = JSON.parse(JSON.stringify(routes));
      if (!this.mobileThreshold) {
        this.getExtraItems(routes);
        this.getNestedGroups(routes);
      }
      return routes;
    },
    getNestedGroups(routes) {
      const vue = this;
      const indexes = this.getNestedIndexes(routes);
      let removedRoutes = _.remove(routes, function(route) {
        return _.get(route, "meta.nestedGroup");
      });
      removedRoutes = _.groupBy(removedRoutes, "meta.nestedGroup");
      _.each(removedRoutes, function(routeGroup, key) {
        const indexObj = _.find(indexes, { key });
        if (indexObj)
          routes.splice(indexObj.index, 0, vue.getSubPageSettings(routeGroup, key));
      });
    },
    getSubPageSettings(routeGroup, key) {
      const vue = this;
      const group = {
        name: key,
        meta: {
          groupName: routeGroup[0].meta.nestedGroup,
          icon: "fa-solid fa-chevron-down"
        },
        tag: "div",
        childItems: routeGroup
      };
      const groupName = routeGroup[0].meta.nestedGroup;
      switch (groupName) {
        case "subPages":
          group.altName = function(route) {
            const routeTitle = _.get(vue.$route, "meta.title");
            const labelPath = "children.0.meta.title";
            const routeMatch = _.find(routeGroup, [labelPath, routeTitle]);
            if (routeMatch) {
              const prefix = vue.$route.query.subPageSource || vue.$store.state.sticky.subPageSource;
              return _.startCase(prefix) + ": " + _.get(routeMatch, labelPath);
            } else {
              return _.startCase(key);
            }
          };
          break;
      }
      return group;
    },
    getNestedIndexes(routes) {
      routes = _.clone(routes);
      const keys = [];
      _.remove(routes, function(route) {
        const nestedGroup = _.get(route, "meta.nestedGroup");
        const firstOccurrence = !_.includes(keys, nestedGroup);
        if (nestedGroup) {
          if (firstOccurrence)
            keys.push(nestedGroup);
          else
            return true;
        }
      });
      _.each(keys, function(key, i) {
        const firstIndex = _.findIndex(routes, {
          meta: {
            nestedGroup: key
          }
        });
        keys[i] = { key, index: firstIndex };
      });
      return keys;
    },
    getExtraItems(routes) {
      const vue = this;
      let additionalItems = [];
      if (!this.$store.state.standalone) {
        const extensionTools = [
          {
            tag: "a",
            href: this.$store.state.urlOrigin + "/library",
            name: "Open Audible library",
            disabled: false,
            meta: {
              icon: "fa-brands fa-audible",
              nestedGroup: "extension-tools"
            }
          },
          {
            tag: "a",
            href: "https://joonaspaakko.gitbook.io/audible-library-extractor/",
            name: "Extension documentation",
            disabled: false,
            meta: {
              icon: "fa-solid fa-graduation-cap",
              nestedGroup: "extension-tools"
            }
          },
          {
            highlight: true,
            tag: "div",
            name: "Save gallery website",
            disabled: false,
            click: this.routeClick,
            meta: {
              icon: "fa-solid fa-download",
              nestedGroup: "extension-tools",
              component: saveGallery
            }
          },
          {
            highlight: true,
            tag: "div",
            name: "CSV export&nbsp;<small>(spreadsheet)</small>",
            disabled: false,
            click: this.routeClick,
            meta: {
              icon: "fa-solid fa-file-csv",
              nestedGroup: "extension-tools",
              component: saveCSV
            }
          },
          {
            highlight: true,
            tag: "div",
            name: "Wallpaper creator",
            disabled: false,
            click: function(route) {
              if (!route.condition())
                return;
              try {
                let covers = _.filter(vue.$store.getters.collection, "asin");
                covers = JSON.parse(JSON.stringify(covers));
                covers = _.chunk(covers, 50);
                let storageObj = {
                  imageEditorChunks: covers,
                  imageEditorChunksLength: covers.length,
                  imageEditorTimeCode: new Date().getTime()
                };
                if (vue.$store.state.pageTitle)
                  storageObj.imageEditorPageTitle = vue.$store.state.pageTitle;
                if (vue.$store.state.pageSubTitle)
                  storageObj.imageEditorPageSubTitle = vue.$store.state.pageSubTitle;
                chrome.storage.local.set(storageObj).then(() => {
                  chrome.runtime.sendMessage({ action: "openImageEditor" });
                });
              } catch (e) {
              }
            },
            condition: function() {
              return vue.$route.meta.gallery && vue.$store.getters.collection && vue.$store.getters.collection.length;
            },
            tippy: function() {
              let txt = "When you open wallpaper creator, books are imported from the current page with the active sorting. Search and filters also affect what gets imported.";
              const nobooks = !(vue.$route.meta.gallery && vue.$store.getters.collection && vue.$store.getters.collection.length);
              const booksWithCovers = _.filter(vue.$store.getters.collection, "cover");
              if (nobooks)
                txt += "<br><br> <strong style='color: #db7e00; font-size: 19px;'>Can't be opened on pages that don't have any books.</strong>";
              else
                txt += "<br><br> <strong style='color: #db7e00;'>Current selection of books " + vue.$store.getters.collection.length + " / " + vue.$store.getters.collectionTotal + ". <br> Importable book covers: <span style='color: #50a900;'>" + booksWithCovers.length + "</span></strong>";
              return txt;
            },
            meta: {
              icon: "fa-regular fa-image",
              nestedGroup: "extension-tools"
            }
          },
          {
            tag: "div",
            name: "Set as gallery landing page",
            tippy: "Click here and any links leading to the extension gallery (in browser context menu or extraction settings) will open this exact page. The url will be saved as is, so all url parameters will be saved as well. This includes: searches, filters, sorting, and some other things. <br><br>For example, open the library page, filter out finished books, click this menu item, and now you don't have to do that every time you open the gallery, if that is what you prefer...",
            disabled: false,
            click: function(route) {
              try {
                const path = window.location.pathname;
                const newUrl = "." + path + window.location.href.split(path)[1];
                chrome.runtime.sendMessage({ action: "changeGalleryUrl", url: newUrl }).then(() => {
                  chrome.storage.local.get(["extras"]).then((data) => {
                    data.extras.galleryUrl = newUrl;
                    chrome.storage.local.set({ extras: data.extras }).then(() => {
                    });
                  });
                });
              } catch (e) {
              }
            },
            meta: {
              icon: "fa-solid fa-house-user",
              nestedGroup: "extension-tools"
            }
          },
          {
            tag: "div",
            name: "Reset gallery landing page",
            disabled: false,
            click: function(route) {
              try {
                const newUrl = null;
                chrome.runtime.sendMessage({ action: "changeGalleryUrl", url: newUrl }).then(() => {
                  chrome.storage.local.get(["extras"]).then((data) => {
                    data.extras.galleryUrl = newUrl;
                    chrome.storage.local.set({ extras: data.extras }).then(() => {
                    });
                  });
                });
              } catch (e) {
              }
            },
            meta: {
              icon: "fa-solid fa-house",
              nestedGroup: "extension-tools"
            }
          }
        ];
        additionalItems = additionalItems.concat(extensionTools);
      }
      if (additionalItems.length) {
        _.each(additionalItems, function(route) {
          routes.push(route);
        });
      }
    },
    routeClick(route) {
      this.clickedRoute = route;
    },
    globalTopNavHeight(mobileSize) {
      this.$nextTick(function() {
        let offset = 0;
        if (!mobileSize) {
          const nav = this.$refs.navigation;
          if (nav)
            offset = Math.floor(nav.getBoundingClientRect().height);
        }
        this.$store.commit("prop", { key: "topNavOffset", value: offset });
      });
    }
  }
};
const _hoisted_1$3 = {
  id: "ale-navigation",
  ref: "navigation"
};
const _hoisted_2$3 = {
  key: 0,
  class: "floater-components"
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_gallery_navigation_looper = __unplugin_components_0$2;
  const _component_gallery_mobile_menu_floaters = __unplugin_components_1$7;
  const _component_gallery_back_forward_btns = __unplugin_components_2$2;
  const _component_gallery_audio_player_ui_mobile = __unplugin_components_3$3;
  return !_ctx.loading ? (openBlock(), createElementBlock("div", {
    key: 0,
    id: "nav-outer-wrapper",
    class: normalizeClass({ regular: !$options.mobileThreshold, "mobile-nav": $options.mobileThreshold, "mobile-nav-open": _ctx.mobileMenuOpen })
  }, [
    createBaseVNode("div", _hoisted_1$3, [
      createVNode(_component_gallery_navigation_looper, {
        routes: _ctx.routes,
        mobileMenuOpen: _ctx.mobileMenuOpen,
        "onUpdate:mobileMenuOpen": _cache[0] || (_cache[0] = ($event) => _ctx.mobileMenuOpen = $event),
        inRoot: true,
        desktopMenu: !_ctx.mobileMenuOpen
      }, null, 8, ["routes", "mobileMenuOpen", "desktopMenu"]),
      !$options.mobileThreshold ? (openBlock(), createElementBlock("div", _hoisted_2$3, [
        $options.clickedRouteComp ? (openBlock(), createBlock(resolveDynamicComponent($options.clickedRouteComp), {
          key: 0,
          onCloseComp: _cache[1] || (_cache[1] = ($event) => _ctx.clickedRoute = null)
        }, null, 32)) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ], 512),
    $options.mobileThreshold ? (openBlock(), createBlock(_component_gallery_mobile_menu_floaters, {
      key: 0,
      mobileMenuOpen: _ctx.mobileMenuOpen,
      "onUpdate:mobileMenuOpen": _cache[2] || (_cache[2] = ($event) => _ctx.mobileMenuOpen = $event),
      mobileThreshold: $options.mobileThreshold,
      onStartSearching: $options.startSearching
    }, null, 8, ["mobileMenuOpen", "mobileThreshold", "onStartSearching"])) : createCommentVNode("", true),
    _ctx.$store.state.displayMode && !$options.mobileThreshold ? (openBlock(), createBlock(_component_gallery_back_forward_btns, {
      key: 1,
      viewportFloat: true
    })) : createCommentVNode("", true),
    $options.mobileThreshold && _ctx.store.showMobilePlayer ? (openBlock(), createBlock(_component_gallery_audio_player_ui_mobile, { key: 2 })) : createCommentVNode("", true)
  ], 2)) : createCommentVNode("", true);
}
var __unplugin_components_1 = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
var galleryBackground_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$2 = {
  name: "aleBackground",
  mixins: [makeCoverUrl],
  data: function() {
    return {
      coverSource: null,
      books: null,
      booksLength: null,
      windowWidth: null,
      timer1: null,
      timer2: null
    };
  },
  mounted: function() {
    this.windowWidth = window.innerWidth;
    this.books = this.getBooks();
    this.flipAnimationRandomizer();
    this.$compEmitter.on("afterWindowResize", this.onWindowResize);
  },
  beforeUnmounted: function() {
    this.$compEmitter.off("afterWindowResize", this.onWindowResize);
    clearInterval(this.timer1);
    clearInterval(this.timer2);
  },
  methods: {
    bgGridSize: function() {
      let bgLength = calculateBgLength(15);
      if (this.windowWidth < 530) {
        bgLength = calculateBgLength(5);
      } else if (this.windowWidth < 760) {
        bgLength = calculateBgLength(6);
      } else if (this.windowWidth < 1e3) {
        bgLength = calculateBgLength(8);
      } else if (this.windowWidth < 1300) {
        bgLength = calculateBgLength(12);
      }
      function calculateBgLength(n) {
        return 6 * n;
      }
      return bgLength;
    },
    getBooks: function() {
      const bgLength = this.bgGridSize();
      this.coverSource = this.$store.state.library.books ? this.$store.state.library.books : this.$store.state.library.wishlist;
      let books = function(books2) {
        const booksLength = books2.length;
        if (booksLength <= bgLength) {
          const fits = Math.floor(bgLength / booksLength);
          const difference = bgLength - booksLength * fits;
          const loopLength = fits;
          let clonedBooks = [];
          for (let i = 0; i < loopLength; i++) {
            clonedBooks = clonedBooks.concat(books2);
          }
          if (difference > 0)
            clonedBooks = clonedBooks.concat(books2.splice(-1, difference));
          return clonedBooks;
        } else {
          return _.sampleSize(books2, bgLength);
        }
      }(_.filter(this.coverSource, "cover"));
      books = _.map(books, function(book) {
        let newObject = _.pick(book, ["cover"]);
        newObject.flipOut = false;
        return newObject;
      });
      this.booksLength = books.length;
      return books;
    },
    flipAnimationRandomizer: function() {
      const vue = this;
      clearInterval(vue.timer1);
      clearInterval(vue.timer2);
      vue.timer1 = setInterval(function() {
        vue.coverSwitcheroo();
      }, vue.randomNumber(1500, 3e3));
      vue.timer2 = setInterval(function() {
        vue.coverSwitcheroo();
      }, vue.randomNumber(3500, 5e3));
    },
    coverSwitcheroo: function() {
      const vue = this;
      const targetIndex = this.randomNumber(0, this.booksLength - 1);
      const targetBook = this.books[targetIndex];
      targetBook.flipOut = true;
      setTimeout(function() {
        const covers = _.filter(vue.coverSource, "cover");
        const newIndex = vue.randomNumber(0, covers.length - 1);
        const newBook = covers[newIndex];
        targetBook.cover = newBook.cover;
        targetBook.flipOut = false;
      }, 850);
    },
    randomNumber: function(min, max) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    },
    onWindowResize: function(msg) {
      if (msg.widthChanged) {
        this.windowWidth = msg.width;
        this.books = this.getBooks();
      }
    }
  }
};
const _withScopeId = (n) => (pushScopeId("data-v-b8b56ef4"), n = n(), popScopeId(), n);
const _hoisted_1$2 = {
  key: 0,
  id: "ale-background"
};
const _hoisted_2$2 = ["src"];
const _hoisted_3$2 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "dimmer-overlay" }, null, -1));
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.books ? (openBlock(), createElementBlock("div", _hoisted_1$2, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.books, (book, index) => {
      return openBlock(), createElementBlock("div", {
        key: book.cover + index,
        class: normalizeClass(["image-wrapper", { "flip-out": book.flipOut }])
      }, [
        createBaseVNode("img", {
          crossorigin: "anonymous",
          src: _ctx.makeCoverUrl(book.cover, 200),
          alt: ""
        }, null, 8, _hoisted_2$2)
      ], 2);
    }), 128)),
    _hoisted_3$2
  ])) : createCommentVNode("", true);
}
var __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-b8b56ef4"]]);
var audioPlayerGlobal = {
  name: "audioPlayerGlobal",
  data: function() {
    return {
      store: this.$store.state,
      howler: null
    };
  },
  watch: {
    "store.audioPlayer.audio"(audioInput) {
      if (audioInput) {
        this.initPlayer();
      } else {
        this.destroyHowler();
      }
    }
  },
  computed: {
    audio: {
      get() {
        return this.store.audioPlayer.audio;
      },
      set(newValue) {
        this.$store.commit("prop", { key: "audioPlayer.audio", value: newValue });
      }
    },
    timeDisplay: {
      get() {
        return this.store.audioPlayer.timeDisplay;
      },
      set(newValue) {
        this.$store.commit("prop", { key: "audioPlayer.timeDisplay", value: newValue });
      }
    },
    timeDisplayLeft: {
      get() {
        return this.store.audioPlayer.timeDisplayLeft;
      },
      set(newValue) {
        this.$store.commit("prop", { key: "audioPlayer.timeDisplayLeft", value: newValue });
      }
    },
    progress: {
      get() {
        return this.store.audioPlayer.progress;
      },
      set(newValue) {
        this.$store.commit("prop", { key: "audioPlayer.progress", value: newValue });
      }
    },
    sample: {
      get() {
        return this.store.audioPlayer.sample;
      },
      set(newValue) {
        this.$store.commit("prop", { key: "audioPlayer.sample", value: newValue });
      }
    },
    audioSource() {
      const source = _$1.get(this.$store.getters.audioPlayerBook, "sample");
      var url = new Url(source);
      if (window.location.protocol === "http:")
        url.protocol = "http";
      return url.toString();
    },
    route() {
      return _$1.get(this.audio, "route", {});
    },
    progressFillerStyle() {
      const style = {};
      if (this.progress)
        style.width = this.progress + "%";
      return style;
    }
  },
  mounted() {
    this.$compEmitter.on("audio-player-scubber-pause", this.scrubberPause);
    this.$compEmitter.on("audio-player-clear-pause", this.clearPause);
    this.$compEmitter.on("audio-player-scrubbed", this.userScrubbed);
    this.$compEmitter.on("audio-player-play", this.play);
    this.$compEmitter.on("audio-player-pause", this.pause);
    this.$compEmitter.on("audio-player-stop", this.stop);
    this.$compEmitter.on("audio-player-seek-back", this.seekBack);
    this.$compEmitter.on("audio-player-seek-forward", this.seekForward);
  },
  beforeUnmount() {
    this.$compEmitter.off("audio-player-scubber-pause", this.scrubberPause);
    this.$compEmitter.off("audio-player-clear-pause", this.clearPause);
    this.$compEmitter.off("audio-player-scrubbed", this.userScrubbed);
    this.$compEmitter.off("audio-player-play", this.play);
    this.$compEmitter.off("audio-player-pause", this.pause);
    this.$compEmitter.off("audio-stop-pause", this.stop);
    this.$compEmitter.off("audio-stop-seek-back", this.seekBack);
    this.$compEmitter.off("audio-stop-seek-forward", this.seekForward);
    this.destroyHowler();
  },
  methods: {
    openBook() {
      const bookASIN = this.book.asin;
      const queryASIN = this.$route.query.book;
      if (this.route && this.route.fullPath !== this.$route.fullPath)
        this.$router.push(this.route.fullPath);
      if (!queryASIN || bookASIN && queryASIN !== bookASIN) {
        this.$nextTick(function() {
          this.$compEmitter.emit("book-clicked", this.book.asin);
        });
      }
    },
    initPlayer: function() {
      let vue = this;
      this.destroyHowler("keepAudioData");
      if (this.$store.getters.mobileThreshold)
        this.$store.commit("prop", { key: "showMobilePlayer", value: true });
      this.$store.commit("prop", { key: "playingAudio", value: true });
      this.howler = new howler.Howl({
        src: this.audioSource,
        autoplay: true,
        loop: false,
        volume: 1,
        onplayerror: function() {
          vue.howler.once("unlock", function() {
            vue.howler.play();
          });
          vue.$store.commit("prop", { key: "audioPlayer.playing", value: vue.howler.playing() });
        },
        onplay(e, a) {
          vue.$store.commit("prop", { key: "audioPlayer.playing", value: vue.howler.playing() });
        },
        onend(e) {
          vue.$store.commit("prop", { key: "audioPlayer.playing", value: vue.howler.playing() });
        },
        onpause(e) {
          vue.$store.commit("prop", { key: "audioPlayer.playing", value: vue.howler.playing() });
        },
        onstop(e) {
          vue.$store.commit("prop", { key: "audioPlayer.playing", value: vue.howler ? vue.howler.playing() : false });
        }
      });
      this.seekToCachedPosition();
      this.howler.customSeek = function(config) {
        config = config || {};
        config.value = config.value || 30;
        const audioLength = vue.howler.duration();
        const seek = {
          going: {
            forward: config.direction === "forward",
            backward: config.direction === "backward"
          },
          at: {
            end: false,
            start: false
          },
          value: null
        };
        const mathMethod = seek.going.forward ? "add" : "subtract";
        seek.value = _$1[mathMethod](vue.howler.current.time, config.value);
        seek.at.end = seek.value >= audioLength;
        seek.at.start = seek.value <= 0;
        seek.value = seek.going.forward ? seek.at.end ? audioLength - 1e-8 : seek.value : seek.at.start ? 0 : seek.value;
        vue.howler.seek(seek.value);
        if (seek.at.start || seek.at.end) {
          vue.updateCurrent();
        } else if (!vue.howler.playing()) {
          vue.howler.play();
        }
      };
      this.howler.current = {
        timer: null,
        time: null,
        timeDisplay: null,
        timeDisplayLeft: null,
        percentage: null
      };
      this.howler.current.timer = setInterval(function() {
        if (vue.howler.playing()) {
          vue.updateCurrent();
          if (document.activeElement)
            document.activeElement.blur();
        }
        vue.updateBookProgress();
      }, 500);
    },
    formatTime(secs) {
      const timeArray = [];
      const addToArray = function(number) {
        timeArray.push((number < 10 ? "0" : "") + number);
      };
      let hours = Math.floor(secs / 3600);
      addToArray(hours);
      let minutes = Math.floor(secs / 60) || 0;
      addToArray(minutes);
      let seconds = secs - minutes * 60 || 0;
      addToArray(seconds);
      timeArray.shift();
      return timeArray.join(":");
    },
    updateCurrent() {
      var seek = this.howler.seek() || 0;
      var duration = this.howler.duration() || 0;
      this.howler.current.time = seek;
      this.howler.current.timeDisplay = this.formatTime(Math.round(seek));
      this.howler.current.timeDisplayLeft = this.formatTime(Math.round(duration - seek));
      this.howler.current.percentage = seek / duration * 100 || 0;
      this.timeDisplay = this.howler.current.timeDisplay;
      this.timeDisplayLeft = this.howler.current.timeDisplayLeft;
      this.progress = this.howler.current.percentage.toFixed(1);
    },
    play: function(e) {
      if (this.howler && !this.howler.playing()) {
        this.howler.play();
      }
    },
    pause: function(e) {
      if (this.howler && this.howler.playing()) {
        this.howler.pause();
      }
    },
    scrubberPause: function(e) {
      let vue = this;
      if (this.howler && this.howler.playing()) {
        this.howler.pause();
        this.clearPause();
        this.howler.pauseTimer = setTimeout(function() {
          vue.howler.play();
        }, 500);
      }
    },
    clearPause: function() {
      if (this.howler)
        clearTimeout(this.howler.pauseTimer);
    },
    stop: function() {
      this.destroyHowler();
    },
    seekBack: function() {
      if (this.howler)
        this.howler.customSeek({ direction: "backward" });
    },
    seekForward: function() {
      if (this.howler)
        this.howler.customSeek({ direction: "forward" });
    },
    userScrubbed: function(scrubber) {
      if (this.howler) {
        var targetTime = scrubber.target.value / 100 * this.howler.duration();
        this.progress = scrubber.target.value;
        this.howler.seek(targetTime);
        if (!this.howler.playing())
          this.howler.play();
      }
    },
    destroyHowler(keepAudioData) {
      if (this.$store.getters.mobileThreshold)
        this.$store.commit("prop", { key: "showMobilePlayer", value: false });
      if (this.howler) {
        this.clearPause();
        if (_$1.get(this.howler, "current.timer"))
          clearInterval(this.howler.current.timer);
        if (_$1.get(this.howler, "unload"))
          this.howler.unload();
        this.howler = null;
      }
      if (!keepAudioData)
        this.audio = null;
      this.$store.commit("prop", { key: "playingAudio", value: false });
    },
    updateBookProgress: _$1.throttle(function() {
      if (this.sample)
        return;
      this.$store.commit("updatePlayerProgress", {
        asin: this.$store.getters.audioPlayerBook.asin,
        progress: this.howler.current.time
      });
    }, 3e3, { "leading": false, "trailing": true }),
    seekToCachedPosition() {
      const cached = _$1.find(this.$store.state.sticky.player.books, { asin: this.$store.getters.audioPlayerBook.asin });
      if (cached)
        this.howler.seek(cached.progress);
    }
  }
};
var galleryApp_vue_vue_type_style_index_0_lang = "";
const _sfc_main$1 = {
  mixins: [audioPlayerGlobal],
  data: function() {
    return {
      general: {
        route: null,
        standalone: null,
        categories: null,
        tippyTheme: "dark"
      },
      window: {
        width: window.innerWidth,
        height: window.innerHeight
      }
    };
  },
  created: function() {
    if (!this.$store.state.sticky.lightSwitchSetByUser) {
      const html = document.querySelector("html");
      html.classList.remove("theme-dark");
      html.classList.add("theme-light");
    }
    let vue = this;
    if (this.checkIf_iOS()) {
      document.querySelector("body").classList.add("is-ios");
    }
    if (this.checkIf_Mobile()) {
      document.querySelector("body").classList.add("is-mobile");
    }
    this.$compEmitter.on("refresh-page", this.refreshPage);
    this.$store.commit("prop", { key: "siteOnline", value: navigator.onLine });
    window.addEventListener("offline", function() {
      vue.$store.commit("prop", { key: "siteOnline", value: false });
    }, { passive: true });
    window.addEventListener("online", function() {
      vue.$store.commit("prop", { key: "siteOnline", value: true });
    }, { passive: true });
  },
  mounted: function() {
    const vue = this;
    window.addEventListener("resize", vue.onWindowResize, { passive: true });
    this.showTheBackgroundGrid();
  },
  beforeUnmount: function() {
    this.$compEmitter.off("refresh-page", this.refreshPage);
  },
  methods: {
    refreshPage: function(callback) {
      if (this.$store.state.showRoute)
        this.$store.commit("prop", { key: "showRoute", value: false });
      this.$nextTick(function() {
        setTimeout(() => {
          this.$store.commit("prop", { key: "showRoute", value: true });
          this.$nextTick(function() {
            if (typeof callback === "function")
              callback(this);
          });
        }, 10);
      });
    },
    checkIf_iOS: function() {
      return [
        "iPad",
        "iPhone",
        "iPod"
      ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
    },
    checkIf_Mobile() {
      const userAgent = _.get(navigator, "userAgent", "").toLowerCase();
      const test1 = _.includes([
        "Android",
        "webOS",
        "iPhone",
        "iPad",
        "iPod",
        "BlackBerry",
        "Windows Phone"
      ], (item) => {
        item = item.toLowerCase();
        return userAgent === item;
      });
      const test2 = navigator.userAgent.includes("Mac") && "ontouchend" in document;
      return test1 || test2;
    },
    showTheBackgroundGrid: function() {
      if (!this.$store.state.showBackground) {
        const vue = this;
        this.$nextTick(function() {
          setTimeout(function() {
            vue.$store.commit("prop", { key: "showBackground", value: true });
          }, 1200);
        });
      }
    },
    onWindowResize: _.debounce(function() {
      const currentWidth = window.innerWidth;
      const currentHeight = window.innerHeight;
      const widthChanged = this.window.width !== currentWidth;
      const heightChanged = this.window.height !== currentHeight;
      if (widthChanged || heightChanged) {
        this.window.width = currentWidth;
        this.window.height = currentHeight;
        if (widthChanged)
          this.$store.commit("prop", { key: "windowWidth", value: currentWidth });
        this.$compEmitter.emit("afterWindowResize", {
          from: "app",
          width: currentWidth,
          widthChanged,
          height: currentHeight,
          heightChanged
        });
      }
    }, 320, { leading: true, trailing: true })
  },
  watch: {
    $route: function(route, previousRoute) {
      let paramsString = route.params ? _.map(route.params, function(value, param) {
        return param + ":" + value;
      }).join(",") : null;
      this.$store.commit("prop", [
        { key: "route", value: route },
        { key: "routeParams", value: paramsString }
      ]);
      this.$nextTick(function() {
        if (this.$store.state.pageTitle && (this.$route.meta.title || this.$route.meta.title === "")) {
          document.title = "ALE \u2022 " + (this.$route.meta.title === this.$store.state.pageTitle ? this.$store.state.pageTitle : this.$route.meta.title + ": " + this.$store.state.pageTitle);
        } else if (route.meta.title) {
          document.title = "ALE \u2022 " + (route.meta.title || "My Audible Library");
        }
      });
    },
    "$store.state.showRoute"(value) {
      if (!value)
        this.refreshPage();
    },
    "$store.state.preventScrolling"(value) {
      document.body.classList[value ? "add" : "remove"]("prevent-scrolling");
    }
  }
};
const _hoisted_1$1 = ["data-version", "data-prevent-scrolling"];
const _hoisted_2$1 = { key: 1 };
const _hoisted_3$1 = {
  key: 2,
  id: "nothing-here-404"
};
const _hoisted_4$1 = { key: 0 };
const _hoisted_5 = { key: 1 };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_gallery_background = __unplugin_components_0;
  const _component_gallery_navigation = __unplugin_components_1;
  const _component_router_view = resolveComponent("router-view");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass({ "mobile-threshold": _ctx.$store.state.windowWidth < 630 }),
    "data-version": _ctx.$store.state.version,
    "data-prevent-scrolling": _ctx.$store.state.preventScrolling,
    style: normalizeStyle({ paddingTop: _ctx.$store.state.desktopPlayerHeight })
  }, [
    _ctx.$store.state.showBackground && !(_ctx.$store.state.standalone && !_ctx.$store.state.siteOnline) ? (openBlock(), createBlock(_component_gallery_background, { key: 0 })) : createCommentVNode("", true),
    createVNode(_component_gallery_navigation),
    _ctx.$route.name !== "404" && _ctx.$store.state.showRoute ? (openBlock(), createElementBlock("div", _hoisted_2$1, [
      (openBlock(), createBlock(_component_router_view, {
        key: _ctx.$route.name + "-" + _ctx.$store.state.routeParams + "-" + _ctx.$store.state.refreshViewTimeStamp
      }))
    ])) : _ctx.$store.state.showRoute ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
      _ctx.$store.getters.searchIsActive && !_ctx.$store.state.searchCollection.length ? (openBlock(), createElementBlock("h3", _hoisted_4$1, "Search: no results")) : (openBlock(), createElementBlock("h3", _hoisted_5, "404: There's nothing here"))
    ])) : createCommentVNode("", true)
  ], 14, _hoisted_1$1);
}
var App = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var normalize = "";
/*!
  * vue-router v4.1.5
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop = () => {
};
const isArray = Array.isArray;
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base2) {
  if (!base2 || !pathname.toLowerCase().startsWith(base2.toLowerCase()))
    return pathname;
  return pathname.slice(base2.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base2) {
  if (!base2) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base2 = baseEl && baseEl.getAttribute("href") || "/";
      base2 = base2.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base2 = "/";
    }
  }
  if (base2[0] !== "/" && base2[0] !== "#")
    base2 = "/" + base2;
  return removeTrailingSlash(base2);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base2, location2) {
  return base2.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base2, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base2.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base2.slice(hashPos)) ? base2.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base2);
  return path + search + hash;
}
function useHistoryListeners(base2, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base2, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base2) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base2, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace2) {
    const hashIndex = base2.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base2 : base2.slice(hashIndex)) + to : createBaseLocation() + base2 + to;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to, data) {
    const state = assign({}, history2.state, buildState(
      historyState.value.back,
      to,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign(
      {},
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace
  };
}
function createWebHistory(base2) {
  base2 = normalizeBase(base2);
  const historyNavigation = useHistoryStateNavigation(base2);
  const historyListeners = useHistoryListeners(base2, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign({
    location: "",
    base: base2,
    go,
    createHref: createHref.bind(null, base2)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function createWebHashHistory(base2) {
  base2 = location.host ? base2 || location.pathname + location.search : "";
  if (!base2.includes("#"))
    base2 += "#";
  return createWebHistory(base2);
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re2 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re2})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re2}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re2 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse(path) {
    const match = path.match(re);
    const params = {};
    if (!match)
      return null;
    for (let i = 1; i < match.length; i++) {
      const value = match[i] || "";
      const key = keys[i - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re,
    score,
    keys,
    parse,
    stringify
  };
}
function compareScoreArray(a, b) {
  let i = 0;
  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i];
    if (diff)
      return diff;
    i++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser, {
    record,
    parent,
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i = 0;
    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))
      i++;
    matchers.splice(i, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign(
        paramsFromLocation(
          currentLocation.params,
          matcher.keys.filter((k) => !k.optional).map((k) => k.name)
        ),
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k) => k.name))
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props === "boolean" ? props : props[name];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers = [];
  function add(handler) {
    handlers.push(handler);
    return () => {
      const i = handlers.indexOf(handler);
      if (i > -1)
        handlers.splice(i, 1);
    };
  }
  function reset() {
    handlers = [];
  }
  return {
    add,
    list: () => handlers,
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name) {
  const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to, from, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
      ).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return normalizeSlot(slots.default, { Component: component, route }) || component;
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode);
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      hash,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace(to) {
    return push(assign(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign({
        query: to.query,
        hash: to.hash,
        params: "path" in newTargetLocation ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace2 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
          force,
          replace: replace2
        }),
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        true,
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          return pushWithRedirect(
            assign({
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
              force
            }),
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to.matched) {
        if (record.beforeEnter && !from.matched.includes(record)) {
          if (isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    for (const guard of afterGuards.list())
      guard(to, from, failure);
  }
  function finalizeNavigation(toLocation, from, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router.listening)
        return;
      const toLocation = resolve(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(error, 4 | 8)) {
          return error;
        }
        if (isNavigationFailure(error, 2)) {
          pushWithRedirect(
            error.to,
            toLocation
          ).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && !isNavigationFailure(failure, 8)) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve2, reject) => {
      readyHandlers.add([resolve2, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve2, reject]) => err ? reject(err) : resolve2());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve,
    options,
    push,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app2) {
      const router2 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router2;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }
      app2.provide(routerKey, router2);
      app2.provide(routeLocationKey, reactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  return router;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
var storeState = {
  sticky: {
    lightSwitch: 1,
    lightSwitchSetByUser: false,
    viewMode: "grid",
    chunkLocation: 0,
    booksInSeriesToggle: false,
    collectionsDrawerToggle: true,
    exportSettingsGallery: null,
    exportSettingsCSVdataSources: null,
    exportSettingsCSVcompatibility: null,
    booksInSeriesAll: true,
    booksInSeriesFinished: true,
    booksInSeriesOpenInApp: true,
    subPageSource: "library",
    bookDetailsCollapsedCover: false,
    bookDetailsCollapsedDetails: false,
    contextMenuReminder: true,
    bookDetailSettings: {
      minHeight: null,
      titleShort: true,
      sidebar: {
        show: true,
        iconToolbar: true,
        seriesList: true,
        collectionsList: true
      },
      carousel: true,
      playButton: true,
      cloudPlayer: false,
      blurb: true,
      statusIndicators: true,
      whispersync: true,
      plusCatalog: true,
      favorite: true,
      finished: true,
      reverseDirection: false,
      hideFirstSection: false
    },
    collectionsHidePremade: false,
    player: {
      books: []
    },
    seriesFilters: {
      inLibrary: null,
      notInLibrary: null
    }
  },
  bookDetailSettingsOpen: false,
  searchMounted: false,
  searchCollection: [],
  mutatingCollection: [],
  collectionSource: null,
  pageCollection: null,
  route: null,
  routeParams: null,
  library: null,
  urlOrigin: null,
  searchQuery: "",
  standalone: null,
  displayMode: null,
  listRenderingOpts: null,
  windowWidth: window.innerWidth,
  showBackground: false,
  chunkCollection: [],
  chunkDistance: 40,
  refreshViewTimeStamp: new Date().getTime(),
  showRoute: true,
  pageTitle: null,
  pageSubTitle: null,
  version: "0.2.9",
  extractSettings: null,
  siteOnline: true,
  searchOptCloseGuard: false,
  bundlingGallery: false,
  bookDetails: {
    book: null,
    index: -1
  },
  searchOptOpenHeight: null,
  devMode: false,
  lazyScroll: true,
  navHistory: {
    btnNavigation: false,
    forward: [],
    back: []
  },
  modal: {
    saveLocally: false
  },
  preventScrolling: false,
  playingAudio: false,
  topNavOffset: 0,
  bookClicked: false,
  audioPlayer: {
    audio: null,
    timeDisplay: "00:00",
    timeDisplayLeft: "00:00",
    progress: 0,
    sample: true,
    playing: false
  },
  showMobilePlayer: false,
  desktopPlayerHeight: null,
  mobileWidth: 630
};
var storeMutations = {
  fromLocalStorage: function(state) {
    const lsState = JSON.parse(localStorage.getItem("aleSettings"));
    if (lsState)
      _.merge(state.sticky, lsState);
  },
  prop(state, config) {
    let setValues = function(config2) {
      config2 = config2 || {};
      if (config2.key) {
        let newValue = config2.freeze ? Object.freeze(config2.value) : config2.value;
        _.set(state, config2.key, newValue);
      }
    };
    if (_.isArray(config)) {
      _.each(config, function(conf) {
        setValues(conf);
      });
    } else {
      setValues(config);
    }
  },
  buildStandaloneData: function(state, inputArray) {
    state.library = state.library || {};
    _.each(inputArray, function(item) {
      if (item.key)
        _.set(state, "library." + item.key, Object.freeze(item.value));
    });
  },
  stickyProp: function(state, o) {
    state.sticky[o.key] = o.value;
  },
  addListRenderingOpts: function(state, o) {
    if (o.sortValues !== void 0) {
      let sortValues = _.find(state.listRenderingOpts.sort, { key: "sortValues" });
      if (sortValues)
        sortValues.active = o.sortValues;
    }
    if (o.splice) {
      state.listRenderingOpts[o.listName].splice(o.splice, 0, o.option);
    } else if (o.unshift) {
      state.listRenderingOpts[o.listName].unshift(o.option);
    } else {
      state.listRenderingOpts[o.listName].push(o.option);
    }
    if (o.activate) {
      if (o.listName === "sort") {
        const currentSorter = _.find(state.listRenderingOpts[o.listName], "current");
        if (currentSorter)
          currentSorter.current = false;
        o.option.current = true;
      } else {
        const currentlyActive = _.find(state.listRenderingOpts[o.listName], "active");
        currentlyActive.active = false;
        o.option.active = true;
      }
    }
  },
  updateListRenderingOpts: function(state, o) {
    let currentList = state.listRenderingOpts[o.listName];
    let currentItem = currentList[o.index === 0 || o.index ? o.index : _.findIndex(currentList, { key: o.key })];
    if (o.sortValues !== void 0) {
      let sortValues = _.find(state.listRenderingOpts.sort, { key: "sortValues" });
      if (sortValues)
        sortValues.active = o.sortValues;
    }
    if (o.active === false || o.active === true)
      currentItem.active = o.active;
    if (currentItem.type === "filterExtras") {
      if (o.range)
        currentItem.range = o.range;
      if (o.value)
        currentItem.value = o.value;
    }
    if (o.listName === "sort" && currentItem.type === "sort") {
      const currentSorter = _.find(currentList, "current");
      currentSorter.current = false;
      currentItem.current = true;
    }
  },
  resetFilters: function(state, o) {
    _.each(state.listRenderingOpts.filter, function(filter) {
      filter.active = filter.type === "filter";
    });
  },
  chunkCollectionReset: function(state) {
    state.chunkDistance = state.sticky.viewMode === "grid" ? 52 : 80;
    state.sticky.chunkLocation = 0;
    state.chunkCollection = [];
  },
  chunkCollectionAdd: function(state, config) {
    config = config || {};
    const searchIsActive = state.searchQuery.trim() !== "";
    const source = searchIsActive ? state.searchCollection : state.mutatingCollection;
    if (source.length > 0) {
      const location2 = config.chunkDistance ? config.chunkDistance : parseFloat(state.sticky.chunkLocation);
      let sliceOfLife = config.chunkDistance ? source.slice(0, location2) : source.slice(location2, location2 + state.chunkDistance);
      if (sliceOfLife.length > 0) {
        if (config.chunkDistance) {
          state.chunkCollection = sliceOfLife;
        } else {
          state.chunkCollection = state.chunkCollection.concat(sliceOfLife);
        }
        state.sticky.chunkLocation = location2 + state.chunkDistance;
      }
    }
  },
  navHistory: function(state, config) {
    const direction = config.pushOnly ? config.key : config.key === "back" ? "forward" : "back";
    state.navHistory[direction].push(config.value);
    if (!config.pushOnly) {
      state.navHistory[config.key].pop;
      state.navHistory.btnNavigation = true;
    }
  },
  updatePlayerProgress: function(state, config) {
    const cachedIndex = _.findIndex(state.sticky.player.books, { asin: config.asin });
    if (cachedIndex > -1)
      _.set(state.sticky.player, "books[" + cachedIndex + "].progress", config.progress);
    else
      state.sticky.player.books.push(config);
  }
};
var storeGetters = {
  sortValues: function(state) {
    const sortValues = _.find(_.get(state, "listRenderingOpts.sort"), { key: "sortValues" });
    return _.get(sortValues, "active");
  },
  sortBy: function(state) {
    const sort = _.find(_.get(state, "listRenderingOpts.sort"), "current");
    return _.get(sort, "key");
  },
  regularFilters: function(state) {
    return _.filter(_.get(state, "listRenderingOpts.filter"), { type: "filter" }).length > 0;
  },
  filterKeys: function(state) {
    return _.map(_.filter(_.get(state, "listRenderingOpts.filter"), { type: "filter", active: true }), function(o) {
      return o.key;
    }).join(",");
  },
  filterKeysLength: function(state) {
    return _.filter(_.get(state, "listRenderingOpts.filter"), { type: "filter" }).length;
  },
  filterExtrasKeys: function(state) {
    return _.map(_.filter(_.get(state, "listRenderingOpts.filter"), { type: "filterExtras", active: true }), function(o) {
      return o.key;
    }).join(",");
  },
  scopeKeys: function(state) {
    return _.map(_.filter(_.get(state, "listRenderingOpts.scope"), "active"), function(o) {
      return o.key;
    }).join(",");
  },
  searchIsActive: function(state) {
    return state.searchQuery.trim() !== "";
  },
  collectionSource: function(state) {
    return state.searchQuery.trim() !== "" ? state.searchCollection : _.get(state, state.collectionSource);
  },
  collectionTotal: function(state) {
    return _.get(state, state.collectionSource, []).length;
  },
  collection: function(state) {
    const searchIsActive = state.searchQuery.trim() !== "";
    if (searchIsActive) {
      return state.searchCollection;
    } else {
      return state.mutatingCollection;
    }
  },
  saveStandaloneAfter: function(state) {
    let extraSettings = _.get(state, "extractSettings.extraSettings");
    if (extraSettings) {
      let saveStandaloneAfter = _.find(extraSettings, { name: "saveStandaloneAfter", value: true, deactivated: false });
      if (saveStandaloneAfter)
        return true;
    }
  },
  audioPlayerBook(state, getters) {
    return _.get(state.audioPlayer.audio, "book", {});
  },
  audioPlayerTitle(state, getters) {
    const book = _.get(getters, "audioPlayerBook", {});
    return book.title || book.titleShort;
  },
  mobileThreshold(state) {
    return state.windowWidth < state.mobileWidth;
  },
  showPageTitle(state) {
    return !!(state.pageSubTitle || state.pageTitle);
  }
};
var store = createStore({
  state: storeState,
  mutations: storeMutations,
  getters: storeGetters
});
const scriptRel = "modulepreload";
const seen = {};
const base = "";
const __vitePreload = function preload(baseModule, deps) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = `${base}${dep}`;
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
const _sfc_main = {
  name: "aleLibraryView",
  mounted() {
  }
};
const _hoisted_1 = { key: 0 };
const _hoisted_2 = {
  key: 1,
  id: "nothing-here-404"
};
const _hoisted_3 = { key: 0 };
const _hoisted_4 = { key: 1 };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_view = resolveComponent("router-view");
  return _ctx.$store.state.showRoute ? (openBlock(), createElementBlock("div", _hoisted_1, [
    _ctx.$route.name !== "404" ? (openBlock(), createBlock(_component_router_view, {
      key: _ctx.$route.name + "-" + _ctx.$store.state.routeParams + "-" + _ctx.$store.state.refreshViewTimeStamp
    })) : (openBlock(), createElementBlock("div", _hoisted_2, [
      _ctx.$store.getters.searchIsActive && !_ctx.$store.state.searchCollection.length ? (openBlock(), createElementBlock("h3", _hoisted_3, "Search: no results")) : (openBlock(), createElementBlock("h3", _hoisted_4, "404: There's nothing here"))
    ]))
  ])) : createCommentVNode("", true);
}
var aleLibraryView = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const aleGallery = () => __vitePreload(() => import(
  /* webpackPreload: true */
  /* webpackChunkName: "gallery" */
  "./gallery-root.921b39a6.js"
), true ? ["assets/gallery-root.921b39a6.js","assets/gallery-root.904539fd.css","assets/gallery-lazy.719d725f.js","assets/lodash.1321b47a.js","assets/jquery.050764e9.js","assets/gallery-makeCoverUrl.8378190f.js","assets/gallery-timeStringToSeconds.9aa0cb6a.js","assets/gallery-secondsToTimeString.0a6fc9ec.js","assets/gallery-search.436556ed.js","assets/gallery-search.61baac67.css","assets/gallery-findSubPageSource.65b5640c.js","assets/gallery-findSubPageSource.63fed0cc.css","assets/gallery-page-title.a786f9b3.js","assets/gallery-page-title.f7b1ec31.css","assets/content-script-helpers.e49fc91b.js","assets/index.ee874ed1.js","assets/howler.22814ddb.js","assets/tippy.82bfa66a.js","assets/tippy.74129432.css"] : void 0);
const aleCollections = () => __vitePreload(() => import(
  /* webpackChunkName: "collections" */
  "./gallery-collections.6a6a4fcd.js"
), true ? ["assets/gallery-collections.6a6a4fcd.js","assets/gallery-collections.220d6805.css","assets/gallery-lazy.719d725f.js","assets/lodash.1321b47a.js","assets/jquery.050764e9.js","assets/gallery-page-title.a786f9b3.js","assets/gallery-page-title.f7b1ec31.css","assets/content-script-helpers.e49fc91b.js","assets/gallery-makeCoverUrl.8378190f.js","assets/index.ee874ed1.js","assets/howler.22814ddb.js","assets/tippy.82bfa66a.js","assets/tippy.74129432.css"] : void 0);
const aleCategories = () => __vitePreload(() => import(
  /* webpackChunkName: "categories" */
  "./gallery-categories.d73c67cb.js"
), true ? ["assets/gallery-categories.d73c67cb.js","assets/gallery-categories.0c203a76.css","assets/gallery-findSubPageSource.65b5640c.js","assets/gallery-findSubPageSource.63fed0cc.css","assets/lodash.1321b47a.js","assets/jquery.050764e9.js","assets/gallery-page-title.a786f9b3.js","assets/gallery-page-title.f7b1ec31.css","assets/content-script-helpers.e49fc91b.js","assets/gallery-makeCoverUrl.8378190f.js","assets/index.ee874ed1.js","assets/howler.22814ddb.js","assets/tippy.82bfa66a.js","assets/tippy.74129432.css"] : void 0);
const aleSeries = () => __vitePreload(() => import(
  /* webpackChunkName: "series" */
  "./gallery-series.fde68d3e.js"
), true ? ["assets/gallery-series.fde68d3e.js","assets/gallery-series.c755adf2.css","assets/gallery-lazy.719d725f.js","assets/lodash.1321b47a.js","assets/jquery.050764e9.js","assets/gallery-search.436556ed.js","assets/gallery-search.61baac67.css","assets/gallery-findSubPageSource.65b5640c.js","assets/gallery-findSubPageSource.63fed0cc.css","assets/gallery-page-title.a786f9b3.js","assets/gallery-page-title.f7b1ec31.css","assets/content-script-helpers.e49fc91b.js","assets/gallery-timeStringToSeconds.9aa0cb6a.js","assets/gallery-makeCoverUrl.8378190f.js","assets/index.ee874ed1.js","assets/howler.22814ddb.js","assets/tippy.82bfa66a.js","assets/tippy.74129432.css"] : void 0);
const aleAuthors = () => __vitePreload(() => import(
  /* webpackChunkName: "authors" */
  "./gallery-authors.e53f59a9.js"
), true ? ["assets/gallery-authors.e53f59a9.js","assets/gallery-authors.fc6718c7.css","assets/gallery-lazy.719d725f.js","assets/lodash.1321b47a.js","assets/jquery.050764e9.js","assets/gallery-search.436556ed.js","assets/gallery-search.61baac67.css","assets/gallery-findSubPageSource.65b5640c.js","assets/gallery-findSubPageSource.63fed0cc.css","assets/gallery-page-title.a786f9b3.js","assets/gallery-page-title.f7b1ec31.css","assets/content-script-helpers.e49fc91b.js","assets/gallery-timeStringToSeconds.9aa0cb6a.js","assets/gallery-makeCoverUrl.8378190f.js","assets/index.ee874ed1.js","assets/howler.22814ddb.js","assets/tippy.82bfa66a.js","assets/tippy.74129432.css"] : void 0);
const aleNarrators = () => __vitePreload(() => import(
  /* webpackChunkName: "narrators" */
  "./gallery-narrators.98530dff.js"
), true ? ["assets/gallery-narrators.98530dff.js","assets/gallery-narrators.1ac18bed.css","assets/gallery-lazy.719d725f.js","assets/lodash.1321b47a.js","assets/jquery.050764e9.js","assets/gallery-search.436556ed.js","assets/gallery-search.61baac67.css","assets/gallery-findSubPageSource.65b5640c.js","assets/gallery-findSubPageSource.63fed0cc.css","assets/gallery-page-title.a786f9b3.js","assets/gallery-page-title.f7b1ec31.css","assets/content-script-helpers.e49fc91b.js","assets/gallery-timeStringToSeconds.9aa0cb6a.js","assets/gallery-makeCoverUrl.8378190f.js","assets/index.ee874ed1.js","assets/howler.22814ddb.js","assets/tippy.82bfa66a.js","assets/tippy.74129432.css"] : void 0);
const alePublishers = () => __vitePreload(() => import(
  /* webpackChunkName: "publishers" */
  "./gallery-publishers.1af28afe.js"
), true ? ["assets/gallery-publishers.1af28afe.js","assets/gallery-publishers.894cb786.css","assets/gallery-lazy.719d725f.js","assets/lodash.1321b47a.js","assets/jquery.050764e9.js","assets/gallery-search.436556ed.js","assets/gallery-search.61baac67.css","assets/gallery-findSubPageSource.65b5640c.js","assets/gallery-findSubPageSource.63fed0cc.css","assets/gallery-page-title.a786f9b3.js","assets/gallery-page-title.f7b1ec31.css","assets/content-script-helpers.e49fc91b.js","assets/gallery-timeStringToSeconds.9aa0cb6a.js","assets/gallery-makeCoverUrl.8378190f.js","assets/index.ee874ed1.js","assets/howler.22814ddb.js","assets/tippy.82bfa66a.js","assets/tippy.74129432.css"] : void 0);
var allRoutes = {
  library: {
    name: "library",
    path: "/library",
    component: aleGallery,
    meta: { gallery: true, title: "Library", icon: "fa-solid fa-book" }
  },
  collections: {
    path: "/collections",
    component: aleLibraryView,
    meta: {
      icon: "fa-regular fa-folder-open"
    },
    children: [
      { name: "collections", path: "", component: aleCollections, meta: { title: "Collections" } },
      { name: "collection", path: ":collection", component: aleGallery, meta: { gallery: true, title: "Collections" } }
    ]
  },
  wishlist: {
    path: "/wishlist",
    component: aleLibraryView,
    meta: {
      icon: "fa-solid fa-bookmark"
    },
    children: [
      { name: "wishlist", path: "", component: aleGallery, meta: { gallery: true, title: "Wishlist" } }
    ]
  },
  subPages: {
    categories: {
      path: "/categories",
      meta: {
        icon: "fa-solid fa-indent",
        nestedGroup: "subPages"
      },
      component: aleLibraryView,
      children: [
        { name: "categories", path: "", component: aleCategories, meta: { subPage: true, title: "Categories" } },
        { name: "category", path: ":parent/:child?", component: aleGallery, meta: { gallery: true, subPage: true, title: "Categories" } }
      ]
    },
    series: {
      path: "/series",
      component: aleLibraryView,
      meta: {
        icon: "fa-solid fa-list-ol",
        nestedGroup: "subPages"
      },
      children: [
        { name: "all-series", path: "", component: aleSeries, meta: { subPage: true, title: "Series" } },
        { name: "series", path: ":series", component: aleGallery, meta: { gallery: true, subPage: true, title: "Series" } }
      ]
    },
    authors: {
      path: "/authors",
      component: aleLibraryView,
      meta: {
        icon: "fa-solid fa-user-group",
        nestedGroup: "subPages"
      },
      children: [
        { name: "authors", path: "", component: aleAuthors, meta: { subPage: true, title: "Authors" } },
        { name: "author", path: ":author", component: aleGallery, meta: { gallery: true, subPage: true, title: "Authors" } }
      ]
    },
    narrators: {
      path: "/narrators",
      component: aleLibraryView,
      meta: {
        icon: "fa-solid fa-users",
        nestedGroup: "subPages"
      },
      children: [
        { name: "narrators", path: "", component: aleNarrators, meta: { subPage: true, title: "Narrators" } },
        { name: "narrator", path: ":narrator", component: aleGallery, meta: { gallery: true, subPage: true, title: "Narrators" } }
      ]
    },
    publishers: {
      path: "/publishers",
      component: aleLibraryView,
      meta: {
        icon: "fa-solid fa-book",
        nestedGroup: "subPages"
      },
      children: [
        { name: "publishers", path: "", component: alePublishers, meta: { subPage: true, title: "Publishers" } },
        { name: "publisher", path: ":publisher", component: aleGallery, meta: { gallery: true, subPage: true, title: "Publishers" } }
      ]
    }
  },
  fallback: {
    path: "/:pathMatch(.*)*",
    name: "404",
    component: aleLibraryView,
    meta: {}
  }
};
function loadRoutes(libraryData) {
  if (libraryData) {
    let routes = [];
    if (libraryData.books) {
      routes.push({ path: "/", redirect: "/library" });
    } else if (libraryData.wishlist) {
      routes.push({ path: "/", redirect: "/wishlist" });
    }
    if (libraryData.books) {
      routes.push(allRoutes.library);
    }
    if (!libraryData.books && libraryData.wishlist) {
      routes.push(allRoutes.wishlist);
    }
    var subPages = allRoutes.subPages;
    let subPageStates = _.get(libraryData, "extras.subPageStates");
    if (subPageStates) {
      _.each(subPageStates, function(item) {
        if (item.enabled)
          routes.push(subPages[item.key]);
      });
    } else if (libraryData.books || libraryData.wishlist) {
      _.each(subPages, function(subPage) {
        routes.push(subPage);
      });
    }
    if (libraryData.collections) {
      routes.push(allRoutes.collections);
    }
    if (libraryData.books && libraryData.wishlist) {
      routes.push(allRoutes.wishlist);
    }
    routes.push(allRoutes.fallback);
    const router = createRouter({
      history: createWebHashHistory(""),
      routes,
      scrollBehavior(to, from, savedPosition) {
        if (savedPosition) {
          return savedPosition;
        } else {
          if (from && to.name === from.name && _.isEqual(to.params, from.params)) {
            return;
          } else {
            return { x: 0, y: 0 };
          }
        }
      }
    });
    const standalone2 = document.querySelector("html.standalone-gallery");
    if (standalone2) {
      let loadScript = function(file) {
        return new Promise(function(resolve, reject) {
          let script = document.createElement("script");
          script.src = (file.prefix || "data/") + file.name + "." + libraryData.extras.cacheID + ".js";
          script.type = "text/javascript";
          script.onload = function() {
            resolve(file);
            script = null;
          };
          script.onerror = function() {
            reject(file);
            script = null;
          };
          document.body.appendChild(script);
        });
      };
      let getJSON = function(to, from, next, files, afterError) {
        files = _.filter(files, function(file) {
          return window[file.name + "JSON"] !== true;
        });
        let promises = [];
        files.forEach(function(file) {
          promises.push(loadScript(file));
        });
        Promise.all(promises).catch(function() {
          if (!afterError) {
            setTimeout(function() {
              getJSON(to, from, next, files, "afterError");
            }, 1e3);
          }
        }).finally(function() {
          let storageArray = _.map(files, function(file) {
            return {
              key: file.keyOverride || file.name,
              value: window[file.name + "JSON"]
            };
          });
          store.commit("buildStandaloneData", storageArray);
          _.each(files, function(file) {
            window[file.name + "JSON"] = true;
          });
          viewRefreshClean(to, from, next);
        });
      };
      router.beforeEach((to, from, next) => {
        if (to.name && (from.name !== to.name || _.get(from, "query.book") !== _.get(to, "query.book") || from.query.subPageSource !== to.query.subPageSource)) {
          const loaderArray = [];
          const openingWishlist = to.name === "wishlist" || to.query.subPageSource === "wishlist" || to.meta.subPage && !to.query.subPageSource && store.state.sticky.subPageSource === "wishlist";
          if (libraryData.wishlist && openingWishlist) {
            loaderArray.push({ name: "wishlist" });
          } else if (libraryData.books) {
            loaderArray.push({ name: "library", keyOverride: "books" });
          }
          if (libraryData.series)
            loaderArray.push({ name: "series" });
          if (libraryData.collections)
            loaderArray.push({ name: "collections" });
          getJSON(to, from, next, loaderArray);
        } else {
          viewRefreshClean(to, from, next);
        }
      });
    } else {
      router.beforeEach((to, from, next) => {
        viewRefreshClean(to, from, next);
      });
    }
    router.afterEach((to, from, next) => {
      if (from.name !== to.name) {
        const navForward = store.state.navHistory.forward;
        const navBack = store.state.navHistory.back;
        if (from.name && from.name !== navForward[navForward.length - 1] && from.name !== navBack[navBack.length - 1]) {
          store.commit("navHistory", { key: "back", value: from.name, pushOnly: true });
        }
        if (!store.state.navHistory.btnNavigation)
          store.commit("prop", { key: "navHistory.forward", value: [] });
        store.commit("prop", { key: "navHistory.btnNavigation", value: false });
      }
    });
    return router;
  }
}
function viewRefreshClean(to, from, next) {
  if (to.query.refresh) {
    delete to.query.refresh;
    store.commit("prop", [
      { key: "showRoute", value: false },
      { key: "refreshViewTimeStamp", value: new Date().getTime() }
    ]);
    next(to);
  } else {
    next();
  }
}
const updateRouterQuery = {};
updateRouterQuery.install = function(app2, options) {
  app2.config.globalProperties.$updateQuery = function(config) {
    config = config || {};
    let query = config.query;
    let value = config.value;
    let history2 = config.history;
    let queries = config.queries || this.$route.query;
    let queryClone = JSON.parse(JSON.stringify(queries));
    if (value === void 0) {
      if (queryClone[query])
        delete queryClone[query];
      else
        queryClone[query] = true;
    } else {
      if (!value)
        delete queryClone[query];
      else
        queryClone[query] = value;
    }
    console.log(query, queryClone);
    if (history2) {
      this.$router.push({ query: queryClone }).catch(() => {
      });
    } else {
      this.$router.replace({ query: queryClone }).catch(() => {
      });
    }
  };
  app2.config.globalProperties.$updateQueries = function(queries, config) {
    config = config || {};
    let history2 = config.history;
    let queryClone = JSON.parse(JSON.stringify(config.queries || this.$route.query));
    _.merge(queryClone, queries);
    _.each(queryClone, function(value, key) {
      if (_.isNil(value))
        delete queryClone[key];
    });
    if (history2) {
      this.$router.push({ query: queryClone }).catch(() => {
      });
    } else {
      this.$router.replace({ query: queryClone }).catch(() => {
      });
    }
  };
};
let openTippy = null;
let tippyScrollContainer = null;
let tippyScrollHide = function() {
  const tippy = openTippy;
  if (tippy && tippy.state.isVisible) {
    tippy.hide();
    tippy.reference.blur();
  }
};
var tippySettings = {
  directive: "tippy",
  component: "tippy",
  componentSingleton: "tippy-singleton",
  defaultProps: {
    placement: "top",
    flipBehavior: ["top", "bottom", "left", "right"],
    allowHTML: true,
    arrow: true,
    theme: "dark",
    maxWidth: 650,
    delay: [500, 0],
    a11y: false,
    onShow: (tippy) => {
      openTippy = tippy;
      tippyScrollContainer = document.querySelector(".list-view-inner-wrap") || window;
      tippyScrollContainer.addEventListener("scroll", tippyScrollHide, { passive: true });
      let content = tippy.props.content;
      if (!content || content === "false")
        content = false;
      return content;
    },
    onHide: (tippy) => {
      if (!tippyScrollContainer)
        tippyScrollContainer = document.querySelector(".list-view-inner-wrap") || window;
      tippyScrollContainer.addEventListener("scroll", tippyScrollHide, { passive: true });
    },
    boundary: "viewport",
    flipDuration: 0
  }
};
var all = "";
const longpress_timeout = 700;
var longPress = {
  created: function(el, { value }, vNode) {
    if (typeof value !== "function") {
      console.warn(`Expect a function, got ${value}`);
      return;
    }
    let pressTimer = null;
    const start2 = (e) => {
      if (e.type === "touchstart")
        e.preventDefault();
      if (e.type === "click" && e.button !== 0)
        return;
      if (pressTimer === null)
        pressTimer = setTimeout(() => value(e), longpress_timeout);
    };
    const cancel2 = () => {
      if (pressTimer !== null) {
        clearTimeout(pressTimer);
        pressTimer = null;
      }
    };
    ["mousedown", "touchstart"].forEach((e) => el.addEventListener(e, start2, { passive: true }));
    ["click", "mouseout", "touchend", "touchcancel"].forEach((e) => el.addEventListener(e, cancel2, { passive: true }));
  },
  unmounted: function(el, binding) {
    ["mousedown", "touchstart"].forEach((e) => el.removeEventListener(e, start, { passive: true }));
    ["click", "mouseout", "touchend", "touchcancel"].forEach((e) => el.removeEventListener(e, cancel, { passive: true }));
  }
};
function touchX(event) {
  if (event.type.indexOf("mouse") !== -1) {
    return event.clientX;
  }
  return event.touches[0].clientX;
}
function touchY(event) {
  if (event.type.indexOf("mouse") !== -1) {
    return event.clientY;
  }
  return event.touches[0].clientY;
}
var isPassiveSupported = function() {
  var supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
  return supportsPassive;
}();
var vueTouchEvents = {
  install: function(app2, constructorOptions) {
    var globalOptions = Object.assign({}, {
      disableClick: false,
      tapTolerance: 10,
      swipeTolerance: 30,
      touchHoldTolerance: 400,
      longTapTimeInterval: 400,
      touchClass: "",
      dragFrequency: 100,
      rollOverFrequency: 100
    }, constructorOptions);
    function touchStartEvent(event) {
      var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0, $el = this;
      if (isTouchEvent) {
        $this.lastTouchStartTime = event.timeStamp;
      }
      if (isMouseEvent && $this.lastTouchStartTime && event.timeStamp - $this.lastTouchStartTime < 350) {
        return;
      }
      if ($this.touchStarted) {
        return;
      }
      addTouchClass(this);
      $this.touchStarted = true;
      $this.touchMoved = false;
      $this.swipeOutBounded = false;
      $this.startX = touchX(event);
      $this.startY = touchY(event);
      $this.currentX = 0;
      $this.currentY = 0;
      $this.touchStartTime = event.timeStamp;
      $this.hasSwipe = hasEvent(this, "swipe") || hasEvent(this, "swipe.left") || hasEvent(this, "swipe.right") || hasEvent(this, "swipe.top") || hasEvent(this, "swipe.bottom");
      if (hasEvent(this, "hold")) {
        $this.touchHoldTimer = setTimeout(function() {
          $this.touchHoldTimer = null;
          triggerEvent(event, $el, "hold");
        }, $this.options.touchHoldTolerance);
      }
      triggerEvent(event, this, "press");
    }
    function touchMoveEvent(event) {
      var $this = this.$$touchObj;
      var curX = touchX(event);
      var curY = touchY(event);
      var movedAgain = $this.currentX != curX || $this.currentY != curY;
      $this.currentX = curX;
      $this.currentY = curY;
      if (!$this.touchMoved) {
        var tapTolerance = $this.options.tapTolerance;
        $this.touchMoved = Math.abs($this.startX - $this.currentX) > tapTolerance || Math.abs($this.startY - $this.currentY) > tapTolerance;
        if ($this.touchMoved) {
          cancelTouchHoldTimer($this);
          triggerEvent(event, this, "drag.once");
        }
      } else if ($this.hasSwipe && !$this.swipeOutBounded) {
        var swipeOutBounded = $this.options.swipeTolerance;
        $this.swipeOutBounded = Math.abs($this.startX - $this.currentX) > swipeOutBounded && Math.abs($this.startY - $this.currentY) > swipeOutBounded;
      }
      if (hasEvent(this, "rollover") && movedAgain) {
        var now = event.timeStamp;
        var throttle = $this.options.rollOverFrequency;
        if ($this.touchRollTime == null || now > $this.touchRollTime + throttle) {
          $this.touchRollTime = now;
          triggerEvent(event, this, "rollover");
        }
      }
      if (hasEvent(this, "drag") && $this.touchStarted && $this.touchMoved && movedAgain) {
        var now = event.timeStamp;
        var throttle = $this.options.dragFrequency;
        if ($this.touchDragTime == null || now > $this.touchDragTime + throttle) {
          $this.touchDragTime = now;
          triggerEvent(event, this, "drag");
        }
      }
    }
    function touchCancelEvent() {
      var $this = this.$$touchObj;
      cancelTouchHoldTimer($this);
      removeTouchClass(this);
      $this.touchStarted = $this.touchMoved = false;
      $this.startX = $this.startY = 0;
    }
    function touchEndEvent(event) {
      var $this = this.$$touchObj, isTouchEvent = event.type.indexOf("touch") >= 0, isMouseEvent = event.type.indexOf("mouse") >= 0;
      if (isTouchEvent) {
        $this.lastTouchEndTime = event.timeStamp;
      }
      var touchholdEnd = isTouchEvent && !$this.touchHoldTimer;
      cancelTouchHoldTimer($this);
      $this.touchStarted = false;
      removeTouchClass(this);
      if (isMouseEvent && $this.lastTouchEndTime && event.timeStamp - $this.lastTouchEndTime < 350) {
        return;
      }
      triggerEvent(event, this, "release");
      if (!$this.touchMoved) {
        if (hasEvent(this, "longtap") && event.timeStamp - $this.touchStartTime > $this.options.longTapTimeInterval) {
          if (event.cancelable) {
            event.preventDefault();
          }
          triggerEvent(event, this, "longtap");
        } else if (hasEvent(this, "hold") && touchholdEnd) {
          if (event.cancelable) {
            event.preventDefault();
          }
          return;
        } else {
          triggerEvent(event, this, "tap");
        }
      } else if ($this.hasSwipe && !$this.swipeOutBounded) {
        var swipeOutBounded = $this.options.swipeTolerance, direction, distanceY = Math.abs($this.startY - $this.currentY), distanceX = Math.abs($this.startX - $this.currentX);
        if (distanceY > swipeOutBounded || distanceX > swipeOutBounded) {
          if (distanceY > swipeOutBounded) {
            direction = $this.startY > $this.currentY ? "top" : "bottom";
          } else {
            direction = $this.startX > $this.currentX ? "left" : "right";
          }
          if (hasEvent(this, "swipe." + direction)) {
            triggerEvent(event, this, "swipe." + direction, direction);
          } else {
            triggerEvent(event, this, "swipe", direction);
          }
        }
      }
    }
    function mouseEnterEvent() {
      addTouchClass(this);
    }
    function mouseLeaveEvent() {
      removeTouchClass(this);
    }
    function hasEvent($el, eventType) {
      var callbacks = $el.$$touchObj.callbacks[eventType];
      return callbacks != null && callbacks.length > 0;
    }
    function triggerEvent(e, $el, eventType, param) {
      var $this = $el.$$touchObj;
      var callbacks = $this.callbacks[eventType];
      if (callbacks == null || callbacks.length === 0) {
        return null;
      }
      for (var i = 0; i < callbacks.length; i++) {
        var binding = callbacks[i];
        if (binding.modifiers.stop) {
          e.stopPropagation();
        }
        if (binding.modifiers.prevent) {
          e.preventDefault();
        }
        if (binding.modifiers.self && e.target !== e.currentTarget) {
          continue;
        }
        if (typeof binding.value === "function") {
          if (param) {
            binding.value(param, e);
          } else {
            binding.value(e);
          }
        }
      }
    }
    function addTouchClass($el) {
      var className = $el.$$touchObj.options.touchClass;
      className && $el.classList.add(className);
    }
    function removeTouchClass($el) {
      var className = $el.$$touchObj.options.touchClass;
      className && $el.classList.remove(className);
    }
    function cancelTouchHoldTimer($this) {
      if ($this.touchHoldTimer) {
        clearTimeout($this.touchHoldTimer);
        $this.touchHoldTimer = null;
      }
    }
    function buildTouchObj($el, extraOptions) {
      var touchObj = $el.$$touchObj || {
        callbacks: {},
        hasBindTouchEvents: false,
        options: globalOptions
      };
      if (extraOptions) {
        touchObj.options = Object.assign({}, touchObj.options, extraOptions);
      }
      $el.$$touchObj = touchObj;
      return $el.$$touchObj;
    }
    app2.directive("touch", {
      beforeMount: function($el, binding) {
        var $this = buildTouchObj($el);
        var passiveOpt = isPassiveSupported ? { passive: true } : false;
        var eventType = binding.arg || "tap";
        switch (eventType) {
          case "swipe":
            var _m = binding.modifiers;
            if (_m.left || _m.right || _m.top || _m.bottom) {
              for (var i in binding.modifiers) {
                if (["left", "right", "top", "bottom"].indexOf(i) >= 0) {
                  var _e = "swipe." + i;
                  $this.callbacks[_e] = $this.callbacks[_e] || [];
                  $this.callbacks[_e].push(binding);
                }
              }
            } else {
              $this.callbacks.swipe = $this.callbacks.swipe || [];
              $this.callbacks.swipe.push(binding);
            }
            break;
          case "press":
          case "drag":
            if (binding.modifiers.disablePassive) {
              passiveOpt = false;
            }
          default:
            $this.callbacks[eventType] = $this.callbacks[eventType] || [];
            $this.callbacks[eventType].push(binding);
        }
        if ($this.hasBindTouchEvents) {
          return;
        }
        $el.addEventListener("touchstart", touchStartEvent, passiveOpt);
        $el.addEventListener("touchmove", touchMoveEvent, passiveOpt);
        $el.addEventListener("touchcancel", touchCancelEvent);
        $el.addEventListener("touchend", touchEndEvent);
        if (!$this.options.disableClick) {
          $el.addEventListener("mousedown", touchStartEvent);
          $el.addEventListener("mousemove", touchMoveEvent);
          $el.addEventListener("mouseup", touchEndEvent);
          $el.addEventListener("mouseenter", mouseEnterEvent);
          $el.addEventListener("mouseleave", mouseLeaveEvent);
        }
        $this.hasBindTouchEvents = true;
      },
      unmounted: function($el) {
        $el.removeEventListener("touchstart", touchStartEvent);
        $el.removeEventListener("touchmove", touchMoveEvent);
        $el.removeEventListener("touchcancel", touchCancelEvent);
        $el.removeEventListener("touchend", touchEndEvent);
        if ($el.$$touchObj && !$el.$$touchObj.options.disableClick) {
          $el.removeEventListener("mousedown", touchStartEvent);
          $el.removeEventListener("mousemove", touchMoveEvent);
          $el.removeEventListener("mouseup", touchEndEvent);
          $el.removeEventListener("mouseenter", mouseEnterEvent);
          $el.removeEventListener("mouseleave", mouseLeaveEvent);
        }
        delete $el.$$touchObj;
      }
    });
    app2.directive("touch-class", {
      beforeMount: function($el, binding) {
        buildTouchObj($el, {
          touchClass: binding.value
        });
      }
    });
    app2.directive("touch-options", {
      beforeMount: function($el, binding) {
        buildTouchObj($el, binding.value);
      }
    });
  }
};
const setListRenderingOpts = {};
setListRenderingOpts.install = function(app2, options) {
  app2.config.globalProperties.$setListRenderingOpts = function(list) {
    if (this.$route.query.sortValues) {
      const sortValuesIndex = _.findIndex(list.sort, { key: "sortValues" });
      list.sort[sortValuesIndex].active = this.$route.query.sortValues;
    }
    if (this.$route.query.sort) {
      let currentSorter = _.find(list.sort, { current: true });
      currentSorter.current = false;
      const sortIndex = _.findIndex(list.sort, { key: this.$route.query.sort });
      if (sortIndex > -1) {
        list.sort[sortIndex].current = true;
        list.sort[sortIndex].active = this.$route.query.sortDir === "desc" ? true : false;
      }
    }
    if (this.$route.query.filter) {
      let paramFilters = decodeURIComponent(this.$route.query.filter).split(",");
      _.each(_.filter(list.filter, { type: "filter" }), function(filter) {
        filter.active = false;
        _.each(paramFilters, function(paramFilter) {
          if (filter.key === paramFilter)
            filter.active = true;
        });
      });
    }
    if (this.$route.query.filterExtras) {
      let paramFilterExtras = this.$route.query.filterExtras.split(",");
      paramFilterExtras = _.map(paramFilterExtras, function(param) {
        return decodeURIComponent(param);
      });
      _.each(paramFilterExtras, function(key) {
        let splitColon = key.split(":");
        let targetKey = splitColon[0];
        let targetItem = _.find(list.filter, { type: "filterExtras", key: targetKey });
        if (targetItem) {
          targetItem.active = true;
          if (splitColon.length > 1) {
            if (targetItem.dropdownOpts) {
              targetItem.value = splitColon[1].split("|");
            } else if (targetItem.range) {
              let splitDash = splitColon[1].split("-");
              let min = parseFloat(splitDash[0]);
              let max = parseFloat(splitDash[1]);
              targetItem.range = [min, max];
            }
          }
        }
      });
    }
    if (this.$route.query.scope) {
      let paramScope = decodeURIComponent(this.$route.query.scope).split(",");
      _.each(list.scope, function(scope) {
        scope.active = false;
        _.each(paramScope, function(paramScope2) {
          if (scope.key === paramScope2)
            scope.active = true;
        });
      });
    }
    this.$store.commit("prop", { key: "listRenderingOpts", value: list });
  };
};
function vuexPrep(libraryData) {
  store.commit("fromLocalStorage");
  store.subscribe(function(mutation, state) {
    if (mutation.type === "stickyProp" || mutation.type === "updatePlayerProgress") {
      localStorage.setItem("aleSettings", JSON.stringify(state.sticky));
    } else if (mutation.type === "prop") {
      _.each(_.isArray(mutation.payload) ? mutation.payload : [mutation.payload], function(payload) {
        const mutationKey = _.get(payload, "key", "");
        const arrayFirstItem_sticky = _.get(mutationKey, "0") === "sticky";
        const startsWith_sticky = arrayFirstItem_sticky || !!mutationKey.match(/^sticky\./i);
        if (startsWith_sticky)
          localStorage.setItem("aleSettings", JSON.stringify(state.sticky));
      });
    }
  });
  const standalone2 = document.querySelector("html.standalone-gallery");
  store.commit("prop", [
    { key: "library", value: libraryData, freeze: standalone2 ? false : true },
    { key: "standalone", value: !!standalone2 },
    { key: "displayMode", value: window.matchMedia("(display-mode: standalone)").matches },
    { key: "urlOrigin", value: "https://audible" + libraryData.extras["domain-extension"] },
    { key: "extractSettings", value: libraryData.config }
  ]);
  if (!libraryData.extras.pages.wishlist)
    store.commit("stickyProp", { key: "subPageSource", value: "library" });
  else if (!libraryData.extras.pages.books)
    store.commit("stickyProp", { key: "subPageSource", value: "wishlist" });
  if (!libraryData.books && libraryData.wishlist)
    store.commit("stickyProp", { key: "subPageSource", value: "wishlist" });
}
const standalone = document.querySelector("html.standalone-gallery");
const app = createApp(App);
app.config.devtools = false;
app.config.productionTip = false;
app.use(shortkey);
app.use(updateRouterQuery);
app.config.globalProperties.$compEmitter = new mitt();
app.use(store);
app.use(VueTippy, tippySettings);
app.directive("longpress", longPress);
app.use(vueTouchEvents);
app.use(setListRenderingOpts);
if (!standalone) {
  try {
    chrome.storage.local.get(null).then((data) => {
      if (!_.isEmpty(data) && data.chunks) {
        helpers.methods.glueFriesBackTogether(data);
        startVue(data);
      } else {
        alert("No existing data found: extract your library again.");
      }
    });
  } catch (e) {
  }
} else {
  let loadJSON = function(afterError) {
    let scrpt = document.createElement("script");
    let cacheID = document.querySelector("#audible-library-extractor").getAttribute("data-cache-id");
    scrpt.src = "data/temp-data." + cacheID + ".js";
    scrpt.type = "text/javascript";
    scrpt.onload = function() {
      let tempData = window.tempDataJSON;
      window.bookSummaryJSON = true;
      scrpt = null;
      startVue(tempData);
    };
    scrpt.onerror = function() {
      scrpt = null;
      setTimeout(function() {
        if (!afterError)
          loadJSON("afterError");
      }, 1e3);
    };
    document.head.appendChild(scrpt);
  };
  loadJSON();
}
function startVue(libraryData) {
  let standaloneRouteData;
  libraryData.extras.pages = libraryData.extras.pages || {};
  if (standalone) {
    standaloneRouteData = JSON.parse(JSON.stringify(libraryData));
    var cleanUp = ["books", "series", "collections", "wishlist"];
    _.each(cleanUp, function(key) {
      if (_.get(libraryData, key) === true) {
        delete libraryData[key];
        _.set(libraryData, "extras.pages.books", true);
        libraryData.extras.pages.books = true;
      }
    });
  }
  vuexPrep(libraryData);
  let router = loadRoutes(standaloneRouteData || libraryData);
  app.use(router);
  app.mount("#audible-library-extractor");
}
export { VueSlider as V, __unplugin_components_0$a as _, makeGoodReadsUrl as a, __unplugin_components_1$5 as b, slugify as c, __unplugin_components_0$7 as d, __unplugin_components_1$2 as e, __unplugin_components_5 as f, __vitePreload as g, __unplugin_components_4$2 as h, makeFullUrl as m, prepareKeys as p, stringifyArray as s };
//# sourceMappingURL=gallery.db031907.js.map
